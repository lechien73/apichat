Learning Outcomes and Assessment Criteria
Front-End
LO1 Design an interactive Front-End web application using HTML and CSS and advanced JavaScript, based on component composition and separation of concerns.
1.1
Design a Front-End for a Full-Stack web application that meets accessibility guidelines, follows the principles of UX design, meets its given purpose and provides a set of user interactions.
1.2
Implement custom JSX (HTML, JavaScript and CSS) code to create a responsive, dynamic Front-End application consisting of one or more pages with relevant responses to user actions and a set of data manipulation functions.
1.3
Write code that meets minimum standards for readability (comments, indentation, consistent and meaningful naming conventions).
1.4
Name files consistently and descriptively, without spaces, capitalisation where recommended, to allow for cross-platform compatibility.
1.5
Document the deployment process for the Front-End application in the README file for the Front-End application.
1.6
Ensure the security of the deployed version of the Front-End application, making sure to not include any passwords in the git repository, and that all secret keys are hidden in environment variables or in files that are in .gitignore, if applicable.
1.7
Implement modular use of components and separation of concerns by incorporating component-specific files (i.e. one JavaScript file and, where applicable, one CSS file per component).
1.8
Include class and/or functional components to build the application.
1.9
Design a responsive Front-End application with the use of a Front-End library which is compatible with React.
1.10
Write code that correctly handles user interactions such as clicks, changes to input fields etc.
1.11
Design a Front-End web application that lets the user initiate and control actions.
1.12
Implement manual testing and document the procedures and results in the README file for the Front-End application.
1.13
Use Git & GitHub for version control of the Front-End application up to deployment, using commit messages to document the development process.
1.14
Deploy a final version of the Front-End application code to a cloud-based hosting platform and test to ensure it matches the development version.

LO2 Explain the key role that specialist Front-End developers perform in modern software development/delivery teams.
2.1
Demonstrate an understanding of the React architecture by documenting the reuse of components in the README file for the Front-End application.
2.2
Document the UX design work undertaken for the Front-End application, including any wireframes, mockups, diagrams, etc., created as part of the design process and its reasoning. Include diagrams created as part of the design process and demonstrate that these have been followed through to implementation.
2.3
Describe what you set out to achieve in creating this application (project goals).
2.4
Document all User Stories and map them to the project goals in the README file for the Front-End application.
2.5
Use Github Projects to implement Agile project management methodology with User Stories mapped to relevant sprints.
2.6
Document Front-End libraries you have used for specific features included in the application and justify your choice in the README file for the Front-End application.

Back-End
LO3 Create an Application Programming Interface (API) for consumption by 3rd party applications.
3.1
Build a Back-End for a Full-Stack web application that allows users to store and manipulate data records about a particular domain.
3.2
Design a database structure relevant for your domain, consisting of a minimum of TWO custom models (excluding user and profile models).
3.3
Write Python code that is consistent in style and conforms to the PEP8 style guide.
3.4
Include custom Python logic to demonstrate your proficiency in the language, e.g.: loops, if statements, DRF framework specific functions and classes.
3.5
Include Back-End framework specific features, e.g., class-based/generic views, permissions, serializers.
3.6
Develop the models (minimum two required) into a usable database where data is stored in a consistent and well-organized manner.
3.7
Create a complete set of CRUD functionality for records in the API.
3.8
Apply login and registration functionality.
3.9
Users should not be permitted write access to restricted content or functionality.
3.10
Implement manual testing and document the procedures and results in the README file for the Back-End application.
3.11
Use Git & GitHub for version control of the Back-End application up to deployment, using commit messages to document the development process.
3.12
Deploy a final version of the Back-End application code to a cloud-based hosting platform and test to ensure it matches the development version.
3.13
Ensure the security of the deployed version of the Back-End application, making sure to not include any passwords in the git repository, that all secret keys are hidden in environment variables or in files that are in .gitignore, and that DEBUG mode is turned off.
3.14
Document the deployment process for the API in the README file for the Back-End application.

Connect Front-End to Back-End
LO4 Create an Interactive Front-End application that consumes API data.
4.1
Create a complete set of CRUD (create, read, update and delete) functionality on the Front-End for users to work with records from an API.
4.2
All changes to the data should be notified to the relevant user on the Front-End application.
4.3
Display and manipulate API data on the Front-End application in a way that brings value to the user and aligns with the project's purpose.
4.4
Implement exception-handling for user actions when communicating with the API, and relay any relevant feedback to the user on the Front-End application.
4.5
Write JSX code that passes through a linter (e.g. eslint) with no significant issues affecting functionality.
4.6
In the Front-End application, implement at least TWO forms, with validation, that allow users to create and edit resources in the Back-End API.
4.7
Ensure that the current login state is evident to the user in the Front-End application.
4.8
Ensure that the final deployed code is free of commented out code and has no broken internal links, or broken links to the API.

Prompt
Act as a senior software developer and head of assessments.  The goal is to create a mapping between the above learning outcomes and associated assessment criteria and the video transcripts to ensure that all assessment criteria are taught
Map one or more assessment criteria to each video transcript.  create a table with three columns, the first column will contain the transcript, the second column will contain the appropriate learning objectives and associated assessment criteria. The third colum will contain the justification for your choice.
Note that each video transcript occurs after a line containing  6 dashes as the first six characters of that line. There are 102 video transcripts.

Also identify any unallocated assessment criteria

------ WyQXfp9Ig4Y ------
ReactJS - more commonly just called React 
- is a powerful, open source JavaScript library
used to create fast and interactive user interfaces.
It is developed and maintained by Facebook,
and used by over 1.7 million live websites as of 2020.
This makes React the most popular of the three
major JavaScript frameworks and libraries,
beating out both the VueJS library and the
AngularJS framework.
Due to its scalability and maintainability,
React is used by many of the largest and most
well known websites in the world, some serving
billions of users, including Facebook, Netflix,
Twitter, Instagram and The New York Times.
At the core of every React application are
components which are small JavaScript files,
usually written in a special JavaScript syntax
called JSX.
Each component on its own is like a miniature
web application.
Components have the ability to make HTTP requests,
communicate with servers and APIs, communicate
with one another, and update themselves in
response to user interactions.
Multiple components are composed together
to create a user interface, where each component
makes up a small part of the UI, like a navigation
menu, an individual tweet or post, a button, or a form.
Individual components are completely independent
of one another, and this means that individual
parts of the user interface can update independently
and in real time, without refreshing the page.
Components are also reusable, which means
you only have to write the code once, and
it can then be reused over and over throughout your application, or even reused in a completely different application.
All these features make React scalable, easy
to maintain and incredibly flexible.
As a front end library, the React philosophy
is to do one thing, and do it really well. 
React is responsible for the way the application
looks and feels.
By coupling it with a full stack framework
like Django, or a back end server environment
like NodeJS, you can build powerful full stack
applications with interactive, asynchronous
front ends capable of being completely disconnected
and independent from the back end.
In the upcoming series of videos, you'll learn
how to build React applications step by step,
and how to integrate them into the full stack
ecosystem.
------ 25gXt5hkj0U ------
In the previous video we 
introduced React - a powerful,  
open source JavaScript library used by 
millions of websites around the world. 
In this video you’re going to learn 
about the structure of a React project.
First we’ll discuss the various 
files and folders in the project  
and then we’ll go over how it all works 
together. I’ve created a template with a  
React project already created and ready to 
go which you can find linked on this page.  
You can copy and use this if you’d like to 
take notes on the various files, or you can  
just follow along with this video. To copy the 
repo, click the button to use the template,  
name and create your own repo, and then click 
the green Gitpod button in your own repo.
As with all projects you’ve seen in Gitpod so far, 
this React project has a file tree on the left,  
our code editing window in the middle, and once 
the app is running, a preview of it on the right.  
You won’t see this at first, but it will show 
up in a moment. The entire project is contained  
within this “react-example” folder. I’ll change 
directories into that folder using the cd command,  
and run the command npm start to start the app. 
This will start the app in the preview window.  
Don’t worry about setting all this up - there 
will be a detailed video on how to create  
all this from scratch but this way at least 
you can see what the running app looks like.
Let’s talk about all these files on the left. 
You can ignore any that say they were modified  
as this happened automatically when we started 
the app, and isn’t important for this video.
I'll begin with package.json. Inside this file is 
a JavaScript object with a number of properties  
defining the configuration for the 
app. For example, it's got a name  
and version number for the app itself and a 
list of dependencies the app needs to run.  
It’s also got some pre-made scripts that can be used to start, stop and test the app among other things. 
This file is highly configurable and can be 
generated automatically by some software, or you  
can create it yourself. You'll learn more about 
how to finesse this file as your React apps become  
more complex. For now you can think of it as a 
sort of configuration file for your React app.
Now let's look at index.html in the public folder.  
This is the file that will be served when 
someone visits your app. There's only one  
key piece of code you need to know about in this 
file, and that's the div with the ID of ""root"".  
This div is where all your react components will 
be rendered at runtime in order to create the user interface.
There's also a noscript tag just 
above that div, which will render the message  
""You need to enable JavaScript to run this app"" 
if the user's browser doesn't support JavaScript.
In the source folder there are several files, but 
we’re only going to focus on a few of them. 
App.js is the react component that renders the 
content you see in the preview window.  
In this case, App.js defines a function called 
App and this is the actual React component.   
The function returns a strange looking combination of 
HTML and JavaScript, and this language is called  
JSX, which you’ll be learning throughout this 
module. At the bottom, the function is exported,  
allowing it to be imported into other files in 
the project, so that it can be reused as needed.
The next important file is index.js. This is the 
JavaScript file that gets run when you first load  
the app. Inside it is where the magic happens. 
First there are some imports including React,  
ReactDom, some CSS, and the app component 
from app.js. Then, ReactDom.render is called  
in order to render the App component in that 
root div with the ID of “root” in index.html.
Lastly, there is an App.css and 
an index.css file in this folder  
which are used to provide some 
simple styling for the app.  
Index.css contains the css for the index.html 
page, and app.css is for the app.js component.  
It would technically be fine to put all this CSS 
in one file, but generally React developers like  
to separate out their component CSS so that if 
they reuse the component, the CSS comes with it.
Now that you know what all these files are, 
let's talk about the flow of the application.  
When someone navigates to your page, 
the empty index.html page is rendered  
containing the shell of the application - the 
basic HTML structure and the empty root div. Then,  
index.js is run, which imports React and React 
Dom as well as the App component, and renders  
the app component into the root div. The app 
component itself is where the actual HTML you  
see in the preview window is defined, and it can 
be modified or reused as required. Most React apps  
have lots of small components like App.js, and 
each component renders a specific part of the UI.
Together, they make up the entire user interface 
and can provide all sorts of interactivity.
So, to review, Index.html contains basic page 
structure and the empty root div, the root div  
ends up with the App component rendered into 
it, and that is done when index.js is run.  
This is the basic flow of any React application.  
The configuration for all these files and how 
they work together is managed with package.json.  
Everything else you see here is secondary to 
understanding how a React application works,  
and you’ll learn more about it as we 
progress through the rest of the videos.
In the next video, you'll learn more about JSX, 
which is the syntax being used in both index.js  
and App.js. After that you'll be ready to 
start building your own components and apps.
------ xR69gE3o_d4 ------
In the last video, we discussed the 
basic structure of a React application.
In this video, you’ll learn more about JSX by 
studying what a react component would look  
like both with and without it. You’ll also learn 
some of the key differences between HTML and JSX. 
JSX is an extension to the JavaScript language 
which allows you to simplify your React code.  
Support for JSX is built into React, so you 
can use it without any special conditions.  
You can think of JSX elements like custom HTML 
tags which can have any name you wish. 
In the example app we discussed in the last video, both 
the App component and index.js used JSX syntax.
Just like regular XML or HTML elements. JSX 
Elements can have attributes like classes,  
ID's and names, and can have 
parents, children and siblings.  
While JSX is not necessary to write React 
applications, in reality React developers  
use it almost universally because it's simpler, 
more elegant and easier to read and maintain.  
Ultimately, when your app is run, the 
JSX code gets transpiled, or converted,  
to the vanilla JavaScript you're familiar 
with, and which your browser can understand.  
If you want to see what a React component looks 
like without using JSX, just take a look at  
this app component to render a simple HTML 
structure like a div with a couple children. 
In this example, instead of returning JSX code, the App component returns a call to React.createElement.
The React.createElement 
function takes three parameters:  
the element to create, in this case a div, an 
object of properties to apply to that element,  
such as class names and IDs, and an 
arbitrary number of children elements.  
In this case, the div has one child, a  
element, which has a child itself, an ,  
and that  itself has a child 
text node containing the text.  
The div and the header have one class 
each, specified by the className property,  
and the  element has no attributes 
so that parameter is set to null. 
In the end, it renders the same result in the 
preview window as the JSX which is commented  
out above, but imagine what this might look 
like if you had a div with 50 nested elements,  
and each of them had children 
of their own with classes,  
IDs and all the other stuff that a typical HTML 
page has. Without JSX, something as simple as  
creating the grid for your page layout or 
creating a form becomes incredibly complex,  
since every single element requires 
this call to react.createElement().  
Creating a real-world react website without 
JSX would be prohibitively complicated.
JSX is simply syntactic sugar, which means 
that it simplifies the syntax for calling  
react.createElement. By using JSX, you can write 
your code so it looks mostly the same as standard  
HTML, but with the added benefit of being able to 
inject and use JavaScript wherever you need to do  
something HTML can't handle. Now, you might notice 
that both with JSX and without it, I'm using the  
property className to define a class for the app 
div. This is because class is a reserved word in  
JavaScript, and we're writing the code in a 
JavaScript file, so we can't use it. Instead,  
when writing JSX code you must use the property 
className. If you inspect the page and look at  
the resulting HTML, you'll see that className 
gets transpiled down to class in the end.
On that note, let's talk about some of 
the differences you'll see in JSX code  
as we work through the rest of these videos. 
First, as mentioned just now, class is always  
replaced with className. Additionally because for 
is a reserved word used for looping in JavaScript,  
if you want to specify a for attribute on 
a label in a form, you must use htmlFor.  
You'll also notice some other standard HTML 
properties and attributes being replaced with  
slight variations. For example, onclick and 
tabindex will be replaced with the camelCased versions,
and you'll see some new attributes 
such as defaultValue when working with forms.  
I’ve provided some additional external 
links and tools on this page which you  
can use for reference to keep 
track of these differences.
Lastly, it's important to remember 
that all custom JSX elements as well  
as the React components they represent, 
must be capitalized like App is here.  
This is so the transpiler that converts the JSX 
to vanilla JavaScript can tell the difference  
between your custom JSX elements and standard 
HTML elements. So remember that all components  
should be capitalized both when defining 
them and when referring to them in JSX code.
If this seems like a lot to remember, not to 
worry. You don't need to memorize it all now  
because there are plenty of warnings and errors 
built into React that will let you know if you've  
forgotten one of these rules. The important parts 
for now are that you understand the value of JSX  
in simplifying your code, and that 
you can recognize when you see them  
that these strange looking 
capitalized HTML elements  
are perfectly valid in JSX, and they 
actually represent React components.
In summary, remember first that React 
developers almost universally use JSX when  
writing React components because it greatly 
simplifies the code. Second, in JSX, you  
need to replace certain attributes such as class 
with className and for with htmlFor.
Third, custom JSX elements represent react components 
and must be capitalized both in their file names  
and in their use in the code, so the transpiler 
can differentiate them from regular HTML. 
In the next video, you’ll learn how to 
create your first React application.
------ KmYoaNroqKc ------
Now that we've gone over all the prerequisites 
you'll need to build React applications,  
and you’ve learned about the structure 
and basic functionality of a React app,  
in this video you'll learn how to set up a 
React application using a tool called npx.
To do this, first you’ll create 
a Github repository for your app,  
create a Gitpod workspace from it, 
and then you’ll use the npx command  
inside your Gitpod workspace to 
create your react application. 
Before we get to that, you should know that to 
get the most out of React we need to couple it  
with an open source, JavaScript runtime called 
NodeJS. The primary thing we’ll be using node for  
is to run our development server 
while we’re writing React code.
Using Node will also take care of converting 
our React code to vanilla JavaScript  
so it can run in the browser, and will 
allow us to use the Node Package Manager  
to install packages and extensions for our React 
apps. In fact, in the React project example we  
looked at a couple videos ago you might recall we 
used the command npm start to start the React app.
Npm stands for Node Package Manager, and it’s 
a tool that is distributed with NodeJS which  
allows us to install and uninstall packages, 
run a development server and even create and  
destroy react applications. So, while it’s not an 
absolute requirement to use Node, react and node  
are often tightly coupled, so we’ll be using Node 
and npm throughout this series. Let’s get started. 
First I'm going to create a repo on Github 
itself, and I'll call mine gitpod-react.  
I’ll use this repo for most of this module. Once 
it's created I'll just click the green Gitpod  
button to open the repository in Gitpod. 
This will create the Gitpod workspace.
Luckily, node is already installed with Gitpod, 
so it’s super simple to create a React app.  
All we need to do is run the command 
npx create-react-app my-app --use-npm.
Npx executes node packages and comes pre-bundled 
with npm, which as you already know is pre-bundled  
with Node. So all three of these tools, Node, 
npm and npx all come together and make it super  
easy to create React applications with 
this simple create-react-app command.
With that complete, npx has created a react app in 
the my-app folder. Everything npm installed went  
into this node_modules folder here, and that’s 
where React will look for any packages it needs.  
To run this app, I first need to cd, or change 
directory, into my-app and run npm start.
Just like that, we’ve got a complete React app 
ready to go and we’re ready to start creating  
our own components. Create-react-app is a great 
little tool that gives us all the boiler plate  
code needed to start a React app and many 
developers like to start here to get their  
apps up and running, and then just delete anything 
they don’t need and make adjustments as required.
Just a side note, here in Gitpod I added 
the --use-npm option when running this  
command because by default Gitpod will 
use yarn, a different package manager.  
I wanted to use npm for this 
series, so I added that option.
So to review, In this video you’ve learned the 
significance of node and npm as well as how to  
create a new React application in a new Gitpod 
workspace using the npx create-react-app command. 
In the next video, you'll learn 
about React developer tools,  
a Chrome extension for troubleshooting 
and inspecting React applications.
------ faF98OpGBr4 ------
In the previous video, you created 
your first React app using npx. 
Before we finish up this lesson and 
move on to creating React components,  
I want to take a quick step back and introduce 
a tool you’ll find handy as you move through  
the rest of this module - React Developer 
Tools. You’ll learn how to install it,  
how to use it to view React components, and some 
features you can use to see how a React app works.
As you've become more skilled in writing HTML, 
CSS and JavaScript, you've undoubtedly realized  
the usefulness of Chrome's dev tools. Dev tools 
gives you an easy way to inspect an element  
to learn about its properties, its CSS styling, 
and how it fits into the rest of the website.  
It also allows you to test various changes to 
the structure and style of your page without  
having to actually make the changes in your code 
until you're sure of what you want to change.
Dev tools also allows you to identify errors 
in your JavaScript through the console and the  
debugger, as well as issues with networking, 
performance, cookies and so on. You might  
notice that I've also got another tab in 
my inspector which isn't there by default.  
The components tab here comes from a chrome 
extension called React Developer Tools,  
and that's what we'll take a look at in 
this video. To install it, just google  
React Developer Tools and install it from the 
Chrome webstore by clicking ""add to Chrome"".  
Once it's installed you can also 
pin it to the Chrome toolbar  
to easily access it whenever you need it. You 
might also need to restart Chrome to enable it.  
I recommend you pause the video now, install 
the extension, and then continue watching.
The reason we need the React developer tools is 
because sometimes we want to be able to examine  
and tweak the actual React application we're 
building, rather than the HTML it generates.  
The first thing to notice with React Developer 
Tools is that it's a great way to identify a site  
that uses React. Whenever you're on a site that 
uses React, the icon will be lit up in either blue  
or orange. If it's blue, it means that the 
site is running the production build of React,  
which is the optimized version, and if it's orange  
it means that it's running the 
unoptimized development version.
Whenever you inspect an element 
on a site that uses React,  
the components tab will automatically highlight 
the element you've selected for inspection.  
On the app we created in the last video 
this isn't very exciting, since we only have  
one component. Let's take a look at something 
more interesting, like Twitter. In this case  
there are thousands of little components all over 
the place, so I'm going to use the element picker  
here in the upper left to pick this tiny 
component here which renders my username.
Just an aside: If you're wondering what 
all these strange looking components are,  
remember that we're looking at the optimized 
production build here, which minifies and  
compresses all component names to keep the 
JavaScript file size as small as possible.
When working on your own project in development 
mode, you'll see your real component names.  
On a complex site like Twitter this won't all 
make sense right away, but don't worry about that.  
This is just to show you some of the things 
React Developer Tools can do. So I've selected  
the username component here, and now I can see 
its props, or properties, over on the right.
In the component's properties, you can see 
things like whether it will show the protected  
or verified icons, whether the ""follows you"" 
badge should be shown for users that follow you,  
whether the screen name should be shown 
and whether the layout of the username  
and screen name should be stacked.  
When working on your own apps, you can use this 
method of inspection to see which properties  
your components currently have and how changes 
to the properties will affect the component.
Another useful tool in the React developer 
tools is component highlighting. If you click  
on the settings here and select ""Highlight 
updates when components render"" you will see  
just how active a large scale React 
application is beneath the surface.  
As I browse around the site, every component 
is briefly highlighted by a box each time it  
rerenders and receives new properties or state. 
Rerenders can be caused by any number of things,  
even something as simple as moving your mouse 
across an element or scrolling on the page.
Each component rerender can be thought of as the 
component being refreshed just like you would  
refresh the page. Often as React applications 
grow in size and complexity, it becomes necessary  
to identify components that are needlessly 
rerendering and slowing the application down,  
and this feature of React developer tools can 
be really helpful in identifying those issues.
Along with the components tab that comes with 
React developer tools is a profiler tab which  
you will find useful in the future. I won't go 
over this now because it won't be useful until  
you're creating more complex React applications, 
but it's good to know that you can use it to  
determine how long different components are taking 
to load and where optimizations might be possible.
As you become more fluent with React you'll 
find the React developer tools to be handy in  
conjunction with Chrome's standard dev tools in 
debugging and optimizing your React applications. 
This is the end of the first set of React 
lessons. So far you've learned what React is,  
the structure of a React application and how 
to set one up for yourself, a bit about JSX,  
and some basics on exploring a React 
application using React Developer Tools. 
In the next video, you’ll begin 
learning how to make your own components  
and how to create interactivity 
in your React applications.
------ n0pUSP8FsCc ------
In lesson one, you learned what React is 
and some of its benefits, the basics of  
how a React application works, as well as 
how to create a new React app from scratch.  
This video marks the beginning of lesson 
two, throughout which you’ll start creating  
your own React components and learning 
how to build more complex React apps.
This video will serve as an introduction to these 
react components, and then throughout the next  
several videos we’ll go into additional detail 
on how to construct them to accomplish a variety  
of tasks. In this video, we’ll review the two main 
types of components in React, stateless functional  
components and stateful class components.
We’ll also talk a bit about React hooks, which are  
a newer React feature that allow us to use some 
features of each component type interchangeably.
Building components is the crux of 
everything you'll do in React, since  
after all, a React application is nothing 
more than a collection of components  
composed together to create a user interface. 
In react there are two main types of components:  
stateless functional components, 
and stateful class components.  
Let's look at an example of each of those. 
If you’d like to duplicate this workspace,  
you can use the Github repo linked on this page, 
or you can just follow along with this video.  
To run the app, I’m going to cd into the 
react-components folder and run 'npm start'.
In this workspace there are three 
components in the components folder:  
FunctionalGreeting, StatefulGreeting, and 
HooksCounter. Each component is written in  
its own JavaScript file so that it can be reused 
as needed, and is capitalized using PascalCase  
so that React can tell it apart from standard 
HTML elements in the JSX. The first component  
is rendered here in the preview window and the 
other two are commented out until we get to them.  
Don’t worry about the details of how this 
works for now - it will be covered in depth  
in the upcoming videos. For now let’s just 
focus on the different types of components.
The first component, functional greeting, is 
what’s known as a stateless functional component.  
As you can see, it is literally just a JavaScript 
function that returns the HTML you see in the  
preview window. And because it’s just a JavaScript 
function, this component can also take parameters.  
The standard is for a component 
like this to take a parameter called  
props, which is short for properties. The props 
parameter contains the properties that determine  
exactly what the component should display, a 
process known as rendering. In the case of the  
functional greeting component, props contains 
a name which is rendered as part of the JSX.  
Where does the actual name come from? It comes 
from the name attribute, which is specified  
wherever we include the component. Using this 
prop, we can use this component to render a  
greeting for any name we wish. The important thing 
to remember about stateless functional components  
is that once they’re rendered with their props, 
their output will always remain the same.
The other type of component in React is a 
stateful class component, and there's an  
example of one here in StatefulGreeting.js. 
While stateless functional components always  
remain the same once they’re rendered, stateful 
class components have the ability to change.  
They do this by using the state, which is just a 
JavaScript object containing various properties.
The initial state, or the values that the 
state has the first time the component renders,  
is defined here in the constructor method. In 
this example the initial state provides the  
component with a state property called count, 
which is initialized to zero. These state  
properties can be accessed within the component by 
accessing this.state, and can be changed at will,  
which means that unlike a functional component 
which is effectively static once it’s rendered,  
stateful class components can be changed 
at any time by simply updating their state.  
There are all sorts of things that can cause the 
state to be updated, but most often, it’s a user interaction.
This component, for example, has 
a button you can click to increment the count.  
When I click the button, this setCount method 
is called which increments the count by one, and  
then rerenders the component with the new state, 
containing the new count. If I click the button again,  
the setCount method is re-run and the 
count increments from this new value of 1 to 2,  
from 2 to 3, and so on. If I refresh the 
preview window, the count is set back to  
zero as it’s defined in the initial state, inside 
the constructor. Stateful components can also take  
props, just like a functional component. 
In a future video, you’ll learn how to  
write both stateless functional components 
and stateful class components from scratch.
So which type of component is best? The answer is, 
it depends. Generally, it's best to use functional  
components as much as you can, and only use class 
components when the component will need to have  
some sort of interactivity. Since they’re less 
complex, functional components are good for those  
static components that just need a couple 
of props to tell them what to render,  
and won’t change after that point, but 
if your component will have any sort  
of interactivity or will change in any way, 
stateful class components are the way to go.
There’s also a link on this page that provides  
some examples of when to use 
different types of components.
Now that you know the two main types of components 
in React applications, let’s talk about React hooks. 
You'll learn more about hooks in a future 
video, but the gist is that a hook is a built  
in React function that you can add to a stateless 
functional component which will allow it to behave  
like a stateful component. Here I've defined 
a functional component called HooksCounter,  
which has identical functionality to the 
stateful component we just looked at.  
Normally, because this is a functional 
component, it wouldn’t be able to have any  
sort of interactivity. Since it’s just a function, 
without hooks it doesn’t have a state and so this  
button wouldn’t be able to do anything at all, 
because there wouldn’t be anything to change.  
If we wanted to be able to display this 
count and allow the button to update it,  
we’d need to use a stateful class 
component like the one we just looked at.  
However, through the use of the useState hook, 
we can give this functional component a state.  
The hook allows us to create a state property 
called count, create a method to update it called  
setCount, provide it an initial value of zero, and 
then call the method when the button is clicked.  
It accomplishes the exact same thing as the 
stateful component with a lot less code. 
In modern React, functional components using hooks 
are increasingly being used as a replacement for  
stateful class components. This is mostly 
due to their ability to accomplish all the  
same things and more while using less code, 
avoiding the complexities of the this keyword  
and eliminating the need to 
worry about the constructor.
Until we get to hooks, we're going to 
use stateful class components because  
in order to truly understand how hooks work, you 
need to understand how state works, and these  
stateful class components will clarify a lot about 
what hooks are actually doing behind the scenes.  
Learning how to use the more complex 
stateful class components will also give  
you a greater appreciation for how much hooks 
simplify the code, once we get to that point.
So, we have stateless functional components 
for components that are simple and don't need  
to change, stateful class components when you 
want your component to have some interactivity,  
and hooks to allow functional components to behave  
like stateful components 
with a lot less complexity.
In the upcoming videos,  
you'll write a functional component from scratch 
and then learn more about how props work.
------ 9H795uo7X5c ------
In the previous video, we looked at 
two different types of components,  
stateless functional components 
and stateful class components.  
We also saw how stateless functional components 
can use React hooks to become stateful.
In this video, let's look at a 
functional component in more detail  
by writing one from scratch. You’ll also learn 
how to use your new functional component by  
exporting it, importing it 
and rendering it in your app.
For this video, I'm using the gitpod-react 
workspace I created in the video about setting up React.
If you don't have your own workspace 
yet, you’ll need it here, so pause this video,  
return to that video which is linked on 
this page and follow the instructions there.  
Otherwise, just open your workspace and 
let’s start writing some React components. 
With your workspace created, you should have an 
app in the my-app folder. We’ll use this app for  
the majority of the rest of the videos by building 
different types of components in it and using  
it to explore different concepts. To begin I'm 
going to start the server by using the cd command  
to enter the my-app folder, and then running 
npm start. If I open the preview window I can  
see the running app. One of the nice things about 
using Node and React is that as you make changes,  
you can see them update in real time just 
by saving the file you're working on.  
If for some reason hot reloading doesn't 
work for you though, you can just refresh  
the preview window or try popping it out 
into a new window to see your changes.
To confirm everything is working, I'm going 
to remove everything except the outer div  
element here and replace it with a heading tag. 
(It works!) As soon as I save, the react  
app reloads automatically. This app function 
is actually a functional component in itself.  
Since we’ve only got that one single 
root div in index.html though,  
and that’s where this app component will be 
rendered and where our whole app will live,  
I’m going to use this component as a parent 
component and nest all other components inside it.
To create our first functional 
component from scratch,  
I'll create a folder here in the src directory 
called components, and inside that folder  
I'll create a file called FunctionalGreeting.js. 
I'm using PascalCase for the filename which means  
we capitalize the first letter of each word in 
the name. This is standard for React components  
and is required for your app to render correctly, 
so make sure you follow this naming convention.
Recall that a functional component is just a 
JavaScript function that returns some JSX to  
be rendered in the UI. This component will just 
return a simple greeting saying Hello from React!  
The first thing to do is import React 
from "react". This line gives us access to  
everything React itself can do, including calling 
react.createElement, which you might recall from  
the JSX video is what JSX will use to create all 
the HTML elements this component will render.  
Also, please note that this line is actually 
not required in the latest versions of React,  
but I wanted to include it here so you really 
understand what’s going on. Including this  
line also makes our components backwards 
compatible with earlier versions of React.  
Anyway, with that done, inside this file let's 
create a new function called FunctionalGreeting.  
It will return a simple h1 element 
that says Hello from React!
This is a perfectly valid functional component, 
but it won't do anything until we include it in  
the rest of the application. To do that, 
we need to first export the function  
from FunctionalGreeting.js, then import it where 
we want to use it, in this case app.js, and then  
we can use it. So first, I'll specify here at 
the bottom: export default FunctionalGreeting.
Now, over in app.js, I'll 
import FunctionalGreeting  
from ./components/FunctionalGreeting. Here, we’re 
just referencing the path to the file where this  
function exists. This will allow us to use the 
FunctionalGreeting component here in app.js.  
This process of writing a component, exporting it, 
and then importing it into your main app file is  
the basis for how we create user interfaces in 
React. All your components for different parts  
of the UI will go into your main app.js, and 
together they make up the whole user interface.
To finish our greeting, I'm going to 
replace the h1 element here in the app div  
with our custom JSX element, . 
Because this component is totally independent  
and won’t have any other content except what it 
renders itself, it doesn’t need a closing tag,  
we just self-close it with a space slash, like an 
input element in regular HTML. Most components can  
be rendered this way, though in more advanced 
apps you’ll definitely see components that wrap  
other components, so if you wanted to close it 
you’d do it just like any other HTML element,  
by closing it with a  
and putting anything else you need within it.  
With that complete, you've created, exported, 
imported and used your first functional component.
It's worth noting by the way that to 
keep our code as modern as possible,  
we could be writing the functional 
greeting component as an arrow function.  
This is a good chance for you to practice this 
process. Pause the video here, take 3 minutes  
to try to convert this component to an arrow 
function, and then unpause it to see the solution.
Luckily, converting this component to an arrow 
function just means making a simple change to 
FunctionalGreeting.js. I'm going to go back 
and comment out the vanilla JavaScript function  
and instead create a constant 
called functionalGreeting,  
equal to an empty set of parentheses, 
then a fat arrow to return the h1 element.  
Everything else can remain exactly the 
same. Personally, I usually write simple  
functions like this which just return a 
line or two of JSX as arrow functions,  
but sometimes it’s easier to visualize exactly 
what’s going on with a regular function. 
You can feel free to use standard functions throughout 
this module, but as an ongoing challenge,  
you could occasionally try writing some of your 
components using arrow functions along the way,  
just to get used to the syntax. After saving 
this file, our React app is still working fine.
Lastly, you might be wondering why we're using 
the word ""default"" here when exporting our component. 
This is so when we import it, we can 
actually do so using any name we want and are not  
required to import it as FunctionalGreeting, 
though it is convention to do so anyway.  
There is another alternative called named exports, 
which you'll learn about as you become more  
advanced in React development, but for now, we’ll 
stick to just exporting everything as default.
So in this video, you've learned how to create 
your first stateless functional component.   
You can now reuse this same component over 
and over again as many times as you want  
throughout the app simply by importing 
it into the file you wish to use it in.  
Remember, this component is stateless, since 
it doesn’t change. It will always render the  
same message, doesn’t have any properties, and 
doesn’t have the ability to update itself in  
any way. It’s just a function that returns some 
JSX, so this is a stateless functional component. 
In the next video, you'll learn how to give 
this component some flexibility by adding props.
------ qO0n71Z7QTE ------
In the previous video, you 
learned how to create your first  
functional component. You did so 
in the file FunctionalGreeting.js. 
In this video, you’ll learn about props, which 
can make this component more flexible and dynamic.
At the moment, when we include our component 
in App.js, it's only capable of rendering  
a single greeting, ""Hello from React"". We can 
duplicate the component as many times as we want,  
but that’s not much use if it always 
returns the same greeting. It would  
be nice if it were able to create different 
greetings. That is where props are useful. 
Props is short for properties, and these 
properties represent the parameters you pass  
into your React component in order 
to tell it what to render and how.
Let's create a duplicate of the 
functional greeting component  
and then rename it to FunctionalGreetingWithProps.  
Inside the file I'll change the name of the 
function, and the name of the export to match.  
Then, I'll go to app.js, import the 
functional greeting with props component,  
and then include it underneath the 
regular functional greeting component.  
You should make a note of these steps since you’ll 
be duplicating components in this way periodically  
throughout the module, and in the future we’ll 
begin the videos with this already done.  
Now, I'll change the greeting to just Hello! to confirm 
the new component is being rendered properly.  
By the way, JSX only wants us 
to return a single element,  
so that’s why I’m leaving everything wrapped 
in this parent div tag. In the previous video,  
there was only a single component inside this 
div, so it technically wasn’t needed, but now  
since we’re returning two components, we 
need to wrap them in a single element.
Anyway, in the preview window 
now we can see both components.  
To keep things clean, I’m going to remove 
the first component and its import,  
but you can import and include any component at 
any time using this same technique. As we progress  
through this series, I’ll try to keep the files 
and code to just the components we’re working  
with in that specific video, but I’d recommend 
that you keep all the components in your project  
so you can import and use them at any time, or use 
them for reference later on. I’d also recommend  
you commit your changes to your repo regularly in 
case anything happens to your Gitpod workspace.
Ok, so we’ve got our new component ready to 
go...now let's learn how to use props.   
Props are specified as attributes to the component, just 
like you would specify any other HTML attribute  
such as class or id. With props, however, you can 
call them anything you wish, and you can specify  
as many as you want. In app.js where I'm rendering 
the  component,  
I'm going to add a prop called greeting. I'll set 
the value of this prop to ""Nice to meet you!"".
So that's all it takes to create a 
prop for a react component. However,  
if you look at the preview window you'll notice 
nothing has changed. In order to use our new prop,  
we have to retrieve it in the component, 
and render it as part of the JSX.  
Let's go to FunctionalGreetingWithProps.js and 
add a parameter in the empty parentheses called props.
This parameter will exist 
as an object inside the function.  
To demonstrate that, let's open a set of curly 
braces for our arrow function, log props to the  
console, and then add the return statement since 
our function now has multiple lines of code.
Now when you open the console, you'll see that 
props contains a key called greeting with the  
value of ""Nice to meet you!"". We can thus access 
this property by injecting some JavaScript code  
into our React component using JSX. I'll 
open a set of curly braces and inside it,  
render props.greeting. Looking now at the preview 
window, the greeting is rendered as expected.  
So just like that, we’ve passed in the greeting 
prop like an HTML attribute, and then rendered it  
in curly braces inside the component. Any time 
you want to use a prop, a JavaScript variable  
or any kind of JavaScript expression in your JSX, 
all you need to do is wrap it in curly braces.
If you want to pass additional props to your 
component, just separate them by spaces, like this. 
Here I’ve added a name prop and an age prop and  
these will all be passed in along with greeting 
in the props parameter we’ve already got.  
So now that we’ve passed them in, before you 
go on to the next video take 2 minutes and  
modify your component to display these two 
props as well. Rewatch the relevant parts of  
this video if you need help, but make sure you 
understand how to do this before moving forward.
In this video, we’ve discussed 
how to add props to a component,  
retrieve them in the component, and then 
render them using JSX. Props are one of  
the tools you'll use throughout your React 
development to make your components dynamic.  
Since you've now got a greeting component that 
accepts props, you can render any greeting you  
wish using the same component. You could even 
add other props to make it even more flexible.  
Props are often used to determine not only what 
the component renders but also how it renders,  
like what colors it should have, whether 
parts of it are enabled or disabled, and so on.  
In effect, they’re just parameters that tell your 
component exactly what you want it to display.
You'll learn more about props and get used to 
using them as you write more react code.   
In the next video, you'll write your first stateful 
class component and then learn how state works.
------ FrJrdejWDi8 ------
In the previous two videos, you learned how 
to write a stateless functional component  
and then how to pass props to it 
in order to change how it renders.
In this video, you’ll write 
your first stateful component. 
First, what exactly do 
stateless and stateful mean?  
Stateless, or functional components, in short, do 
not keep track of anything internal to themselves.  
They always render the same thing whether 
that includes props or not, and once rendered,  
they cannot change unless 
they are given new props.
Stateful components on the other hand 
maintain their own private, internal set  
of properties that describe what they display 
and how they behave. This set of properties  
is maintained in the state object, and can 
be updated in response to user interactions  
like clicking a button, moving the mouse, 
or typing something on the keyboard.  
Stateful components can take props as 
well, but just like functional components,  
once the component is rendered 
these props cannot be changed.  
The state, however, can be updated 
and changed at will, which allows  
stateful components to be more dynamic and 
flexible than their stateless counterparts.
To demonstrate, let’s recreate the functionality 
of the functional greeting with props component,  
but this time using a class component. I'll 
create a new file called StatefulGreeting.js,  
and inside it, import React from ""react"". 
Now, to create a class component,  
simply use the class keyword and give 
your class a name. class StatefulGreeting.  
This will be the name of the component, 
just like how in a functional component, the  
function name is the name of the component. At the 
bottom, I'll also need to export the component,  
so it can be imported into the App.js file in 
a few moments. Export default StatefulGreeting.
Right now, this class is not truly a React 
component. It's just a regular old JavaScript class.
To turn it into a React component, we must 
extend the built-in Component class from React,  
by adding extends React.Component here 
in the class definition. Alternatively,  
we could import { Component } directly from 
React at the top and extend just Component.  
As a reminder, it's very important to 
pay attention to capitalization in React,  
in particular when defining component 
names and when extending React.Component.  
Component names should always be PascalCase 
so React can tell them apart from regular  
HTML elements when we include them in our JSX,  
and both React and Component must be capitalized 
to ensure we extend the class properly.
Ok so we’ve got our class defined. Now we need 
to learn how to actually get it to render the  
content we want. While functional components 
can simply return the JSX to be rendered,  
classes don't have the ability to return anything.
For this reason, all class components must 
define a render() method which returns the JSX.  
So here inside the component, 
I'll define a render method,  
and inside it, return a greeting. “Hello from the 
stateful class component!” I can now go to App.js,  
import the stateful greeting component, 
and include it in the top level app div.  
When everything is saved, your preview window 
should now show the stateful greeting component. 
The only thing left to do to completely duplicate 
the functionality of the functional greeting  
with props component is to pass a greeting 
prop to the class component and render it.  
I'll pass in a greeting of ""I'm a stateful class 
component"" then go to StatefulGreeting.js and  
replace everything after hello with props.greeting 
in curly braces. If you save this file though,  
you'll see it generates an error, 
failed to compile, props is not defined.  
This is because in order to access 
props in a stateful component,  
we need to refer to them as part of 
the class by using the this keyword.  
To access the greeting, all we need to do is 
change props.greeting to this.props.greeting.
As a small additional challenge, try adding 
a name prop to this component as well,  
and rendering it as part of the greeting. 
With that you've successfully duplicated the 
functionality of the functional greeting with  
props component using a stateful class 
component, and you might be wondering  
why we would use the stateful class component when 
it's more complex and does the exact same thing.
You'll learn the answer to that 
question in the next video.
------ Fe-VBr_sfnM ------
In the previous video, you learned how to 
duplicate the functionality of a stateless  
functional component using a stateful class 
component. To quickly review the key points:
First, you create a class component by using 
the class keyword, and the name of the class,  
in Pascal Case, is the name of the component. 
Second, the class must extend React.Component,  
and have a render method which 
returns the JSX to be rendered.  
And third, to access props inside of a stateful 
class component, you must use the this keyword.
So what is the advantage of using class 
components? Well, in the previous video,  
I mentioned that class components have the ability 
to maintain their own internal state, which  
is a private, internal set of properties that 
describe what they display and how they behave.  
This means that unlike functional 
components, class components are  
able to change and update themselves at 
will, or in response to user actions.  
In this video, we’ll show you how to add 
state to your component, then over the  
next few videos we’ll explore how to update 
that state in response to user interactions.
Going back to StatefulGreeting.js, 
I'm going to add a constructor,  
which is a special method that is always 
called when the class is first instantiated.
While state can be defined elsewhere, the 
constructor is where state is usually defined  
in class components. To define the state in the 
constructor, we can simply define this.state,  
and set it equal to an empty object. That 
means as soon as this class is instantiated,  
it will automatically have a property called state 
which we can access and manipulate as required.  
In a moment, we'll give this object 
some properties which can be changed.
First though, there's 
something else we need to do.  
Inside the constructor, the very first thing you 
must always do is call the super function.   
This ensures that the constructor for the parent class, 
importantly React.Component, is also called.  
It's also a best practice to pass props to both 
the constructor method and the super function,  
so that any props you've passed into the component 
are also passed through when calling super.  
It's not important right now to 
understand exactly why this is needed,  
but you should make it a habit to ensure 
your constructors always take on this form.
Now let's get back to the state itself.  
So we have the constructor method defined 
and we've called super and defined a state  
object for our class. The next step is 
to give the state object some properties.  
These values are called the initial state, 
and they will represent the initial values of  
anything the component might change either on its 
own or due to user interaction. To demonstrate,  
let's make the introduction here, ""Hello"", a 
mutable state property. Ultimately, what we want  
is to add a button to the component, and when the 
button is clicked, the introduction will change  
from hello to goodbye. Also, when the button is 
clicked, we will change the text of the button.
The initial value of the introduction should be 
hello, so I'll define a property in the state  
called ""introduction"" and 
give it the value of ""Hello!"".  
Now I'll add another property called buttonText, 
and give it the value of Exit. If this doesn't  
make sense yet, don't worry. It will 
come together over the next few videos.
The last thing to do is render these state values 
in the JSX returned from the render method.   
First, let's add the button element. We need to 
add parentheses to the return statement  
since it will be returning multiple lines 
of code now, and we also need to add an  
enclosing div tag, since React wants 
only one element returned from render.  
I can now put the h1 element inside 
the div, and add the button below it. 
To access the state in the render method, 
you can do it just the same as props:  
using the this keyword. So here I will 
replace Hello with this.state.introduction,  
and in the button element I 
will add this.state.buttonText.
Our component now has its own state, 
which we can manage in a variety of ways.  
To demonstrate, I’ll open the app in a new window,  
open the inspector and use React Dev Tools 
to inspect the StatefulGreeting component.
It’s important to open the app in a new window, 
since otherwise you’ll end up looking at Gitpod’s  
React code rather than your own. If you look on 
the side here, you can see the state we added  
and its values. If you change these values, 
you'll see the component update accordingly.
So to add state to a class component, 
first we have to define the constructor,  
call super, then add the initial state object 
inside the constructor. The constructor will  
be called whenever the class is instantiated and 
will take care of setting up the initial state.  
To access a state property in the component,  
we can use this.state and access 
whichever property is needed.
Whenever these state properties are updated, 
the component rerenders accordingly. 
Of course, we can't expect our users to 
update the state of their React components  
using React Dev Tools. The whole point is to 
allow the component to do this itself or in  
response to user interactions. You'll learn how 
to handle that scenario in the upcoming video.
------ B4jxEe5C_zY ------
We left off at the last video with updating 
our component's state from React dev tools.
In this video, let's look at how to make our 
button functional, allowing it to update the  
state of the StatefulGreeting component. To 
update the state we need to do three things:  
First, we'll need to handle the click of the 
button by giving it an onClick attribute. 
Second,  we'll need to write an event handler method that actually listens to the click event.
And third, in the event handler we'll need to 
use the setState method to update the state.
Let's begin by adding the 
onClick attribute to the button.  
On the opening button tag, I'll add 
an attribute called onClick, and it's  
very important that this is camelcased or React 
won't recognize it. So onClick with a capital C.  
Since I want to use Javascript code, the value of 
this will need to be in curly braces, and inside  
the curly braces, will be an arrow function 
that calls a method called this.handleClick().  
The reason we’re using an arrow function rather 
than just calling this.handleClick() directly  
will be explained in more detail later 
on so don't worry about that for now.  
What's important is that you understand 
that ultimately the purpose of this  
is to call the handleClick() method, which 
we’ll write in a moment. The handleClick()  
method can be named whatever you want, but it's a 
good practice to stick to naming your methods and  
variables for what they actually are. Here it's 
a click handler, so I'll call it handleClick.
That's step 1. Now whenever we click the button,  
the handleClick() method will be called. Of 
course the next step is to actually define the  
handleClick() method. This event handler will 
exist as a property of the class itself. 
So, outside the render method, I'm going to 
define a new method called handleClick().
To confirm it's working, inside it let's just log  
'button clicked!' to the console. 
I can now open the console,  
click the button and see the message logged. The 
button is working as expected, and that’s step 2.
The third and final step is to use the click 
handler to actually update the state. We need  
to do this using a built in React method 
called setState, but first I want to show  
you why by demonstrating an important 
nuance of updating the state in React.  
In the handleClick method, I'm going to modify the 
state directly by setting this.state.introduction  
equal to goodbye. This seems like it 
should work, and means that, theoretically,  
when the exit button is clicked, the 
introduction will change from hello to goodbye.  
I'm also going to log 
this.state.introduction to the console.
If you save that, open the console, and click the 
exit button, you'll see there's a problem. The new  
state value is being logged to the console, 
and it also appears that the state has been  
successfully updated when looking at the state 
in React dev tools, but the component itself  
is not updating. This is the main reason 
you should never update the state without  
using the setState method. When you attempt to 
update the state directly as we're doing here,  
the component will not rerender, and the 
new values will not be shown in the UI.
To fix the problem, we need to use 
the built in setState method of the React.Component class.
Let's go 
back to the handleClick method  
and replace that direct state update 
with a call to this.setState().
The syntax is simple. All we need to do is provide 
the new object we want to use as the state, so in  
this case, it will be an object with the property 
introduction set to goodbye. This is going to be  
the new value that gets put into the state. Notice 
that we’re not using this.state.introduction here,  
since we’re setting the property to a new value, 
rather than getting it from the existing state.
Now another nice thing about using setState 
is that not only will setState make sure the  
component rerenders after the state is updated, 
but it will also merge the new state with the old one,
so the other state property, buttonText, will 
still be included in the updated state and won’t  
be modified unless you modify it in the setState 
method. Instead, setState just merges everything  
together and updates any values you specify. Let's 
see if it's working now. When I refresh the page,  
and click the Exit button, I see the 
component has successfully updated.
So, to review how state updates work in React,  
first we added the on click attribute to our 
button to make a call to the handleClick() method.  
Then, we defined the handleClick method 
in the component, and finally, we made a  
call to this.setState() and passed it an object 
containing the state values we want to replace,  
which is merged with the existing state. Before 
you go on to the next video, see if you can use  
this same call to setState to update the text 
of the button to “Enter” when it’s clicked.  
If you’ve got it right, whenever you click 
the button the introduction should change  
from hello to goodbye, and the button 
text should change from exit to enter.
Pay close attention to the value of 
the introduction that is logged to the  
console when you click the button for 
the first time after loading the page.  
Try clicking it again and see if what’s logged 
to the console changes. Do you notice anything  
unusual going on? If not, try refreshing the 
preview window and clicking the button again.  
If you didn’t catch it, not to worry. 
We’ll review the solution to the challenge,  
and explain this subtle issue with 
the console logging in the next video.
------ SMGs9UXqXqQ ------
In the last video, you learned how to update the 
state in a component using the setState method.
At the end of the video I asked that you pay 
close attention to how the introduction was  
logged to the console. You might have noticed that 
although the component was updating correctly,  
the introduction being logged to the console was 
the one that existed before the state was updated.  
If you didn’t catch that, keep watching 
to see exactly what went wrong.  
We’re going to explore why it happened 
and how to fix it in this video.
To understand what happened, we’ll explore 
two new concepts: asynchronous functions,  
which are functions that are capable of 
executing in the background while other  
code continues executing, and callback functions, 
which have multiple definitions, but in this case,  
are functions that are executed only once the 
code in an asynchronous function completes.
Let’s get started. For this video I’ve duplicated 
the component from the previous video and named  
it StatefulgreetingWithCallback.js. I’ve included 
that one in App.js and I’m working with that new  
component in this video. First, let’s quickly 
go over the solution to the small challenge at  
the end of the last video. Remember, when we first 
created this component we said we wanted it to not  
only update the introduction to say goodbye but 
also to update the text of the button. To do that,  
I’ve added the buttonText property in the 
setState method here and given it a value of "Enter". 
The idea is that when you click exit, the 
introduction will change to goodbye and the button  
text will change to “Enter”. I’ve also logged 
this.state.buttonText to the console so it’s  
crystal clear what the problem is. I'll save that 
and head back to the browser and open the console.
When I click exit, you can see that it logs both "hello" (the introduction), and "exit" (the text of the button)  
to the console, but both the 
introduction and the button text in the component  
are updated correctly. It's sort of like it's 
logging the old values to the console, even though  
the new ones are being rendered in the component. 
As it turns out, that's exactly what's happening.  
The values you see in the console 
are the values that the state had  
just before the button was clicked.
The reason that this happens is that 
calls to setState are asynchronous,  
that is, setState is an asynchronous function 
- the first new concept we’re exploring in  
this video. This means that, effectively, 
setState is executing in the background  
while the rest of the code continues 
executing. So what is happening is that  
these two console.logs are executing before the 
state update actually happens. What you're seeing  
in the console are in fact the old values that 
were in the state before setState was called.
To resolve this issue there’s a second 
form of the setState method we can use,  
which takes another parameter - a callback 
function - as the second parameter. The callback  
function will always execute after setState 
is finished. In fact, you’ve seen this type  
of callback function before when you learned 
about the fetch API. Since fetch can take some  
time to go out and make requests or download 
data, you passed a callback function to it  
that would rely on the fetch call completing, 
and once it did so, the callback function would execute.
This callback function we’re about to 
pass to setState functions exactly the same way.
So here, after the object with the new state 
in it, I'm going to pass in a second parameter,  
an arrow function. The arrow function 
will log the same things to the console,  
but I'm going to add a little note to 
specify that we're looking at the new state.  
Let's save that and go back 
to the console. I'll refresh,  
and now when I click the exit button, you can see 
the correct values in the console, labelled with “new state”.
This brings us to a rule to follow when working 
with setState. Anytime you need to run some code  
after the state update is complete, place the code 
in a callback function as the second parameter to  
setState, NOT immediately after the setState 
call. If you place it after the setState call  
like we did in the previous component, the code 
may execute before the state update is finished.
So in this video, you’ve learned that setState is 
asynchronous, which means it may execute in the  
background while other code continues executing 
in the foreground. You’ve also learned how to  
deal with this by passing a callback function to 
the setState method, which is guaranteed to always  
execute after the state update is complete. What I 
want you to remember from this video is the second  
rule of working with setState: if you have code 
that must run after the setState call is finished,  
make sure you put that code in a callback 
function like we’ve done in this video.
The last problem we need to solve 
in order to complete this component  
is that since the click handler we've written 
only changes to the state in one direction,  
once we click the button once and the state 
changes, the button doesn’t work anymore.   
We need a way to check the value of the introduction 
and the button text in the state and update the UI accordingly. 
If the introduction is hello, we 
want to change it to goodbye and vice versa,  
and the same goes for the button 
text switching between enter and exit  
each time it’s clicked. We'll look at how 
to do this final step in the next video.
------ Sa6OKKgInrw ------
So far we have talked about two crucial 
rules for updating the state of a component.
First, never update the state directly. 
Always use the setState method. Second,  
whenever you have code that must be 
executed after the state update is complete,  
put it in a callback function passed as the 
second parameter to the setState method. 
In this video, you’ll learn about an issue 
that occurs when dealing with state updates  
that depend on the previous state of the 
component. To get started I’ve once again  
duplicated the component from the last video here, 
renamed it to StatefulGreetingWithPrevState.js,  
and imported it and included it in App.js. We’ll 
use this component for this video and the next.
The behavior I want to create in this component 
is such that when the introduction says Hello  
and the exit button is clicked, the introduction 
changes to goodbye, and the text of the button  
changes to enter. Then, when the button is 
clicked again, this time with Enter on it,  
the introduction will change back to hello 
and the text of the button back to exit.  
To do this, we need to determine 
what the current value of the  
introduction and the button text are 
and then set the state accordingly.
It should be fairly simple to do this. Let's use 
a ternary conditional statement in the setState method.
For Introduction, I'll set it equal 
to this.state.introduction === ""Hello!"" ?  
""Goodbye!"" : ""Hello!"". This means that if the 
introduction is hello, it will change to goodbye,  
and otherwise, it will change back to Hello. Now, 
pause the video for 2 minutes and see if you can  
do the same for switching the button text between 
“Enter” and “Exit”. Ok, so hopefully you came up  
with this for your solution.
One thing to note here, is that the reason 
we’re using the this keyword here in this  
part is because we’re going to GET the value from 
the current state and check whether it’s “Hello”  
or “Goodbye”, whereas here, 
we’re just setting a property called introduction  
on a standard JavaScript object. If 
you didn’t get this for your solution,  
make any needed corrections before moving forward. 
Let’s save our component, click the button,  
and we can see it's working fine.
Despite the simplicity of this task,  
we're not quite done yet. Unfortunately, though it 
seems like everything is working correctly, there  
is a problem hidden beneath the surface that will 
only be exposed in a slightly more complicated scenario.
To expose it I want to ask you to 
complete a small challenge: add an “Increment”  
button which, each time it’s clicked, will 
increment a count property in the state by one.
To do so you’ll need to do three things: First, 
add the count property to the state and give it an  
initial value of zero. Next, add an increment() 
method similar to the handleClick() method.  
Your increment() method should use the 
setState method to add one to the value  
of the count property in the state. Last, 
add a button similar to the “Enter/Exit”  
button which calls the increment method 
when clicked, and then render the count  
property along with the greeting so you 
can see the value of the count in the UI.  
Take 5 minutes now to complete this 
challenge, but don’t spend too long  
since we’ll be going over the solution right 
after this. If you can’t figure it out, just come  
back to see the solution after trying for a few 
minutes. Pause the video now and give it a shot.
Alright, welcome back! Hopefully you’ve come 
up with some sort of solution. Let’s go over  
the solution I used. If you’re like most people, 
you probably did it the intuitive way, like this.  
First, I just added the count to the state and 
gave it a value of zero. Then I created an  
increment method, inside which I’ve made a call 
to this.setState and passed in the new count,  
setting it equal to this.state.count + 1. 
Then, for the button, I’ve just copied the  
other button and changed the method to call 
this.increment() in the onClick attribute.
Once again, I can save this and it appears 
everything is working correctly. The count is  
incrementing by 1 each time I click the increment 
button. So if I’m getting the exact behavior I want, 
what’s wrong with this code? To expose the 
problem with it , let's create one last method, incrementFive()
This might seem a little odd, 
and you probably would never see code like this  
in reality, but I want to do it here to show you 
what’s really going on under the surface.   
Inside this method I'll simply call this.increment() 
five times. I’ll also log this.state.count to  
the console in the increment method so we can 
see what it is each time the method is called.  
Last, I'll just change the increment button 
to call our new method and update its text.
Based on this code, what should happen is that 
this.increment should be called five times,  
incrementing the count by 1 each time. Let's see 
if that actually happens. When I click the button,  
the count is incremented to 1. Click 
it again and it's incremented to 2.  
So even though we are calling this.increment five 
times, which should technically increment the  
count by five, it's only incrementing the count 
by 1. Further, if you look at the console you'll  
see that it actually logs the same value five 
times, one for each time the method is called.
The reason for this behavior is that React will 
group multiple calls to setState into a single  
call for better performance. So what's really 
going on here is that the five calls to setState,  
one each time this.increment is called, are 
being grouped into a single call to prevent the  
component from rerendering five times. Instead, 
React groups all the state updates together  
and rerenders only once on the final call to 
this.increment. It doesn't even update the  
state in between calls. This is why even 
though it appeared everything was working  
correctly both in incrementing the counter and 
in changing the introduction and the button text,  
this is not the correct way to update 
the state based on the previous state.
In the final video about state, you’ll 
learn the correct way to do this.
------ MOAuvjT7m8Y ------
In the previous video, you learned about an 
issue that occurs when trying to update the state  
based on the previous state of a React component. 
You learned that the reason for this behavior is  
that React groups calls to the setState method 
together in order to improve performance.
In this video, you’ll learn the correct 
way to deal with this type of update.
When dealing with state updates that depend 
on the previous state of the component,  
there is a third form of the 
setState method you must always use.
This third form takes a function 
as the first parameter to setState.  
The function can take two parameters, 
previous state, and previous props,  
and returns the object that will be used to 
create the new state. In the same component we  
used in the last video, let's update our increment 
function with a new call to this.setState, and as  
the first parameter pass in an arrow function 
that takes previous state and previous props.  
First, I'll log previous state and previous props 
to the console so you can see what they look like,  
and then return the new state which will be an 
object with count equal to prevState.count + 1.  
Let's see if it's working now.
I'll open the console and click the increment 
button. Now the count is incremented correctly,  
and you can see both the previous state and 
previous props here in the console, where each  
time increment is called the count is updated by 
1 and we see its last value in the previous state.
This brings us back to the original goal of the 
last two videos: to update the button text and  
the introduction accordingly, depending on what 
they already are. Remember that the ultimate goal  
here is to create a button that will update 
the introduction to goodbye if it’s hello  
and vice versa, and simultaneously update its 
own text back and forth between exit and enter.  
Now that we know about the third form of the 
setState method, we can update the handleClick  
method to use the third form of setState 
which can deal with the previous state.
Since this is incorrect, I’ll delete 
everything we've got so far and add a  
new call to this.setState which takes an 
arrow function using previous state and  
previous props as the first parameter. For good 
measure I'll copy the console logs from below  
and put them in here as well. Then I'll return 
the new object we want to use for the state,  
which can be almost the same as what we had 
before, but instead of updating this.state,  
we’ll be updating prevState for both 
the introduction and the buttonText.  
Heading back to the browser, 
everything is now working as expected.
One of the tricky things about React is that 
often even though things appear to be working  
as expected, there may be hidden issues you 
won’t see until your code becomes more complex.  
Because of this it’s really 
important to follow best practices  
and make sure not to cut corners, 
especially when working with setState.  
Not doing so can result in strange problems that 
are difficult to debug as this example shows.
So let’s do a quick review. Over the last four videos, you’ve learned three key rules to remember when updating the state in React. 
Rule number 1, never update the state directly. Always use the setState() method.  
Rule number 2, setState calls are asynchronous. 
Therefore, if you’ve got any code that
must be executed after a setState call is completed, put it in a callback function as the second parameter.
And rule number 3, always use this third form of setState whenever you need to update 
the state based on the previous state. 
We've created a small cheat sheet showing the three 
forms of setState which you can use for reference.
You also learned that in general, updating 
the state in react takes three steps:  
giving your element, like a button, an event 
handler such as onClick, writing your event  
handler such as handleClick() or increment() 
which can handle the event when it happens,  
and properly calling setState inside your 
event handler in order to update the state.
One of the things we haven’t gone into 
much detail on is why we’re using an arrow  
function here in the onClick attribute, and 
exactly how this whole event handling process works.
You’ll learn all about that 
over the next couple of videos.
------ dA-oHX0E3Ls ------
Up to now we’ve been writing all 
our React components manually. 
Since you’re now becoming more familiar with 
creating functional and class based components,  
I want to take a quick detour 
before we get to event handling  
and install a small extension in Gitpod that will 
make it a lot easier to set up your components.
To set up this extension, click 
on the extensions button in Gitpod  
and type in React, look for the ES7 
React/Redux/GraphQL snippets extension  
and click install. Gitpod will ask you if 
you want to do it for just this workspace  
or for all your workspaces and I recommend 
installing it for all workspaces.
This helpful little extension gives us a 
bunch of auto-complete snippets we can use  
to create different types of React 
components among many other things.  
To demonstrate let’s create a new file 
called ES7Snippets.js. While this file  
is in the components folder, we won’t actually 
use it as a component. I just want to use it to  
make a note of the most common snippets we’ll 
be using so you can keep it as a reference. 
Inside the file we’ll cover six 
snippets that will come in really handy.
First, to create and automatically export a new 
functional component, we can use the snippet rfce  
and press tab or enter. As you can see this 
automatically takes care of importing React,  
creating the function, and 
exporting it at the bottom too.  
It also highlights the name of the function so 
it’s super easy for you to just type whatever  
name you want right away. I’ll just leave 
the function called ES7Snippets for now.
The second snippet is rafce  
and this will do the same as above except 
it will create and export the component  
as an arrow function. The third snippet is rce 
which will create and export a class component.
It uses the other form of importing Component in 
curly braces that we briefly mentioned in earlier  
videos, where it imports Component directly 
and then extends that, but either way is fine.  
Usually I just end up using this method since this 
is how the snippet creates it. Inside the class  
component, there’s also a snippet for creating the 
constructor, which is rconst. That one is quite  
handy since it automatically drops the cursor 
into the this.state object which makes it quick  
and easy to add state to your class components 
and start adding properties to the state.
Finally, there is clg to log 
something to the console,  
and clo if you want to log an object 
along with its name as a string.
So we have rfce, rafce, rce, rconst, clg and clo. 
There may be others we’ll pick up along the way,  
but at a minimum we’ll definitely use 
these throughout the rest of the lessons  
to speed things up. If you forget 
them, just drop back into this file  
and find the one you need.
In the next video, you’ll start learning the 
finer details of event handling in React.
------ 4p6jLTvRg00 ------
At this point you've seen both functional and 
class components in action, and learned how to  
work with both props and state in React. In all 
of those cases, modifying the state or the props  
changes what the components render. All web 
applications respond to user interactions,  
and in React specifically, user interactions 
are usually how the various components will  
be updated. To handle these interactions 
we capture and respond to events such as  
clicks, mouse movements, scrolling, key presses 
and so on as the user uses the application.
In fact, you’ve already seen these types of events 
in action: we used a click event to trigger state  
updates in the videos about updating the state, 
and you also saw click events triggering state  
updates in the introductory video about React 
components. Both the stateful class component  
and the counter component which used hooks in that 
video used a click event to trigger state updates.
In this video, let's take a closer 
look at how to handle events in React.  
In particular, we’ll work with the click event 
in this video, but almost all events in React  
are handled in exactly the same way, and we’ll 
give you some resources at the end that you can  
use as a reference for the other events. By 
the end of this video, you’ll understand how  
to handle events both in stateless functional 
components and in stateful class components
Let's begin with how to handle events in 
a functional component. Like I said we’ll  
use a click event for now, since that’s a 
pretty common event anyway. For this video  
I’ve already created the files we’ll need 
- EventsFunctional.js and EventsClass.js,  
so before getting started I’ll just give a 
brief overview of these files and their output.  
Inside EventsFunctional.js I used the snippet rfce 
to create and export a new functional component  
which returns a single div including a button 
in it that says click me - functional component.
In EventsClass.js, I used the snippet rce to 
create the class component, and it’s basically  
the same except the button says “click me - class 
component”. To render them in the preview window,  
I’ve imported and included both components in 
App.js. Before you move forward, pause the video  
and use this as an opportunity to test your skills 
with creating these two basic components using the  
appropriate ES7 snippets, and make sure you can 
get everything to match what’s on the screen here.
Now that you’ve created your components, let's 
learn how to capture the click event. In react,  
most event handlers have the same names 
as their standard HTML counterparts  
such as onclick, onmouseover, onkeypress 
and so on. The only difference is in React,  
they're camel cased. So, to capture 
the click event on this button,  
we just need to give it an onClick attribute 
and make sure that it is camel cased.
All events in react are passed to their elements 
as JSX attributes such as onClick here, and their  
values will be specified in curly braces. So here 
I'll open a set of curly braces and within them  
I'll pass a function called clickHandler. 
This is the function that will be called  
when the button is clicked. So now, all 
we need to do is define the function.  
Function clickhandler, and inside it, 
console.log, Clicked the functional button.
There are a few important things to note 
here. First, make sure that the onClick  
attribute is camel cased. Second, ensure that the 
clickHandler function is inside the component,  
not defined outside the EventsFunctional function.  
Finally, make sure you do NOT use parentheses 
after the click handler when passing it.  
We want to pass the function itself, not a call 
to the function, as the event handler. Now I can  
open the app in a new tab, open the console, and 
see the message logged when the button is clicked.
Now let's duplicate the same 
thing in the class component.
Conveniently, defining an event handler in a 
class component is nearly identical to doing so  
in a functional component. In a class component, 
we define the handler as a method on the class,  
so we don't need the function keyword. So here 
outside the render method we can just create a  
method called clickHandler(), and inside it log 
""Clicked the class button"". The other difference  
is that when passing the handler to the onClick 
attribute, we need to use the this keyword.  
So now heading back to the browser, we can see 
that both of our buttons are working just fine.
If you want to work with different events such 
as mouse movements, scrolling, keyboard actions  
and so on, the process is exactly the same as 
we've done here. The only difference is which  
attribute you pass, and you can pass as many as 
you want to create any interactions you require.  
For a full listing of all the events available 
in React, you can take a look at the events  
reference linked on this page. So once again, in 
both class components and functional components,  
first we add the onClick attribute pointing 
at the function we want to call when the  
button is clicked, then write the event 
handler to actually handle the event.
Now you might have noticed that this code doesn't 
look exactly the same as when we did it in the  
earlier components we created. Specifically, 
in the StatefulGreeting components, we used  
arrow functions to pass the event handlers to the 
onClick attribute, and they also used parentheses.  
There’s a very important reason for that, and 
you’ll learn what it is in the next video.
------ JBPf1N0EOzM ------
In the previous video, you learned how to 
handle events by creating event handlers  
in both functional and class components. 
In this video, we’re going to discuss four 
different ways of binding event handlers in React.
Binding event handlers is a method of properly 
connecting your event handlers to your React  
components. There are several ways to 
do this, so I’ll show you each of them  
and then share which ones I 
use in different situations.
To understand why binding is necessary in React, 
I want to take a quick look at the differences  
between the stateful component we made in the 
last video and the original StatefulGreeting.js  
component from a few videos ago. I’ve brought both 
of those components back into the file tree here  
and also I’ve created a duplicate of the 
StatefulGreeting component called EventBinding.js.  
The only one I’m including 
in App.js is EventBinding.js.
Now I’m going to open EventsClass.js 
and StatefulGreeting.js so we can  
compare them side by side. The main thing 
to notice about the two components I’ve got  
open is what happens when the button is 
clicked. In the EventsClass component,  
the component itself doesn’t change, we’re just 
logging a message to the console and that’s it.  
In the other component, however, 
the button triggers a state update,  
and therefore we need to use an arrow function 
in the onClick attribute in that component.
Now let's go to EventBinding.js. Currently it 
functions exactly the same as the StatefulGreeting  
component. Let’s remove the arrow function 
from the onClick event and see what happens.  
I'll save the file, click the button, and you can 
see it generates an error - cannot read property  
setState of undefined. This implies that this, 
in our event handler is undefined, and that's  
exactly what's going on. We need this to refer to 
the component we’ve created, since as an extension  
of the Component class from React, that’s the 
only way we can access the setState method.
However, in JavaScript classes, methods are not 
automatically bound to the class itself, so unless  
we manually bind the method to the class, the this 
keyword will be undefined. If I comment out the  
setState call and log this to the console in the 
event handler, you'll see it is in fact undefined.  
So this is the major reason that in class 
components we need to bind the event handler  
to the class. Without doing so, we can’t 
use this.setState because this is undefined. 
To bind the event handler, there 
are four different ways to do it.  
The first way is to use an arrow 
function, as we've already seen.  
Using an arrow function ensures that 
this is bound to the class, since arrow  
functions execute in the scope in which they're 
created, in this case, our React component.
When using an arrow function, we use parentheses 
after the function since we want to return a call  
to the function. In effect, you're saying 
you want to create a function on the spot  
which returns a call to your event handler. 
If I save this and go back to the browser,  
the button works and this is now defined, 
referring to the component and all its properties.
The second way to bind event handlers to a 
class component is to call the bind method on  
the handler and pass in this, which, outside the 
context of the event handler, refers to the class.  
So effectively here, what you're saying 
is you want this in the handleClick method  
to refer to this from the class, and 
you'll use that as your event handler.
The third method is to bind the event handler 
in the constructor. So, in the constructor,  
we can set this.handleClick equal 
to this.handleClick.bind(this).
Again, this effectively connects the this in the 
event handler, which otherwise would be undefined,  
to this in the class. The difference is by doing 
it in the constructor, it only happens once,  
instead of on every render, which is better 
for performance in large applications. 
The final way to bind the event handler is to do 
it when you actually define the handler itself  
by using an arrow function. So I'll copy 
this handler and comment out the first one,  
then redefine it to use an arrow function instead.
Since I'm using an arrow function when defining 
the method, I can keep the onclick attribute set  
to just this.handleclick. This works because 
again, arrow functions “adopt” the this from  
wherever they're defined, which in 
this case is the class component. 
So with all these methods, which method is 
best? The answer is, it really depends on  
your application, and even though I do have 
a preference, it’s still important to be able  
to recognize them all in case you see them 
in other codebases or your preferred method  
doesn’t work for some reason. That said, for 
most applications I usually go with method 4  
since it's easy to remember to just define all my 
handlers as arrow functions. If your event handler  
needs to take parameters though, the easiest 
way to pass them is to use an arrow function  
in the render method, so I will use that if the 
need arises. I seldom use the other two methods. 
There are some performance implications 
for whichever method you choose,  
but for most cases either using an arrow 
function in the render method or just  
defining your event handler as an arrow function 
in the first place is going to be the best option.
So, option 1, use an arrow function 
in the render method. Option 2,  
bind the handler in the render method. Option 3, 
bind the handler in the constructor. And option 4,  
define your event handler using an arrow 
function. I recommend you stick with option  
4 for now. We may occasionally use option 1 if 
we need to pass a parameter to an event handler,  
but most of the time option 4 will be just 
fine. I’ve also created a small cheatsheet  
linked on this page to help you remember the 
different methods and their pros and cons.
In the next video, we'll talk about 
conditional rendering in React,  
which will let your component render 
different content based on various conditions.
------ X3-fc_yrDqI ------
In the last video, you learned why we need 
to bind event handlers in class components  
as well as the four different methods of doing so.
In this video, you'll learn how to make your  
components render different content depending 
on state and props - a technique known as  
conditional rendering. We’ll go over this for 
both functional components and class components.
I’ve created two new components, 
ConditionalRenderingFunctional.js  
and ConditionalRenderingClass.js. I used the rfce 
and rce snippets respectively to create them,  
and have imported and included both in App.js.
Again, conditional rendering refers to allowing 
your React component to render different content  
depending on various conditions. For example, 
you might have a menu component that renders a  
different menu depending on whether or not a user 
is logged in, or a chart component that renders a  
loading icon while loading the data for the chart, 
and then renders the actual chart once the data is ready.
To understand how to do this we'll start 
simple. In ConditionalRenderingFunctional.js 
I'll add some props and then in app.js I’ll give it 
a prop called connected, set to true. Our goal  
is to render one thing if connected is true, 
and something else if connected is false.
Basically, to achieve this we need an if statement 
in our render method. The most common way to  
do this in ES6 is using the ternary conditional 
statement. Let's create a simple h1 element inside  
the main div and open a set of curly braces so we 
can use some simple JavaScript in our JSX code.  
In the curly braces, I'm going to specify 
props.connected, question mark, 'Connected',  
colon, 'Not connected'. By now you should know 
that ternary conditionals are basically shorthand  
if statements, so what this is really saying 
is if props.connected is true, render the  
string connected inside this h1, otherwise, 
render not connected. Let's see if it works.
In the preview window you can see right now it 
says connected, if I change the prop over in  
app.js to false and save the file, the output 
changes to not connected. This is the essence  
of conditional rendering in React. In class 
components it works pretty much identically.
I'll go to ConditionalRenderingClass.js and this 
time we'll use a state property to decide what  
to render. First we need a state, so let’s 
use our handy rconst snippet and press tab.  
Similar to the other component, I'll add a state 
property called isLoaded and set it to false.
Now in the main div I'll do the same as before,  
creating a simple h1 element and inside a set of curly braces, rendering 'this.state.isLoaded ? data loaded : loading '.
In this way, if the state 
property is true, we will see the message  
data loaded, and otherwise we'll see loading. 
Right now the preview window shows loading  
since isLoaded is set to false. If I change it to 
True, the preview window changes to Data Loaded.
Of course, eventually you'll need to render 
something more than just a simple heading element.  
If you need to conditionally 
render multiple lines of code  
it's as simple as wrapping the parts of 
your ternary conditional in parentheses.  
Let's add another state property to this 
component called isLoggedIn and set it to false.
Under the heading we just created let's open a set 
of curly braces. Inside them I'll create another  
ternary conditional to check if the user is logged 
in and open a set of parentheses for each result.  
Anything in this first set of parentheses 
will be returned if isLoggedIn is true,  
and anything in the second set 
will be returned if it's false.
Now I can put anything I need in 
these parentheses. For example,  
let's say if the user is logged in we want to give 
them a list of things to do to finish signing up.  
I'll create a div, and inside it a 
paragraph that says welcome to the site! 
Please complete the steps below. Then I'll 
open an ordered list and create three list items.  
One to confirm your email, one to complete your 
profile, and one to subscribe to the newsletter.  
In this second set of parentheses, let's just 
return a paragraph that says please sign in.
Now I can see in the preview window 
that the app is telling us to sign in.  
If I change isLoggedIn to true in the state, we 
see the list of steps to complete. Just like that,  
we're rendering totally different 
content based on the state and props.
When you combine this knowledge with 
what you've learned over the last  
several videos about using events to handle 
user interactions, you should be starting  
to understand how it's possible to create 
powerful interactive applications in React.
If we were to add a form and a sign in 
button to this component for example,  
we could give it a click handler that called out 
to a database to verify the user's information,  
and if successful, updates isLoggedIn to true, 
rendering the new UI. We could also make our  
component call out to an API and once a response 
is received, update the state and render the  
data instead of the simple string we're rendering 
now. With a couple small additions to what we’ve  
already done we could have a component with login 
functionality and the ability to talk to an API.
You'll learn to do all this as we 
progress through the rest of the videos.  
For now the important thing to understand is 
how you can use ternary conditionals to render  
different content based on various conditions 
in both functional and class based components. 
In the next video, you'll learn how 
to nest components within one another  
to create even more advanced user interfaces.
------ rwpIBOHjsI4 ------
We finished the last video using a class component  
that renders different content 
based on various state properties. 
In this video, we'll expand on that component 
by extracting the parts of it into separate  
components, then using those new components to 
learn how to nest components within one another.  
This is a critical part of understanding how to 
create more complex user interfaces in React.
To get started, duplicate 
the ConditionalRenderingClass  
component from the last video into a new 
component called NestingComponents.js,  
and include the new component in app.js. We’ll 
use this one to learn about nesting components.  
Remember that you can duplicate a 
component by just right clicking it,  
selecting duplicate, and then 
renaming it appropriately.
Now, in general it's a good idea to keep your 
react components as small and simple as possible.  
You want each component to be as isolated and 
reusable as possible so you can use it in other  
parts of your application or in a different 
application later. You also want each component  
to be used for only one thing or maybe a couple 
at most. This helps to ensure that if anything  
goes wrong in any of your components, the issue 
will mostly be isolated to just that component  
and won't break the rest of your application. 
With that in mind I want to make some changes  
to the component we created in the last 
video in order to break it up a little.
In this component we have two distinct pieces: 
The data message at the top and the user message  
at the bottom. For the purposes of this 
video let's assume we want to break those  
off into their own components, and rather 
than render this messy looking JSX,  
we’ll nest our new components within this parent 
component and render those new components instead.  
Let me show you what I mean: I'll create 
two new files, one called UserMessage.js,  
and one called UserData.js. Given 
what these two components will render,  
can you think of which type of component we might 
need for each one? Should these components be  
stateless functional components, or will they 
have their own state and need to be stateful?  
Pause the video before you go further 
and think about this for a minute or two.
If you said functional, you’re right. Both 
of these components will just be displaying  
static information that won’t change once it’s 
rendered and they don’t have a ny interactivity,  
so they can both be functional. The state will 
be managed here in the parent component, and the  
values for the children will be passed in as props 
from the parent state. Therefore the children  
can be functional, but the parent component must 
remain stateful. I'll start with UserMessage.js.  
Inside it I'll use the snippet rfce to create a 
functional component, and then give it some props.
Now, I'm going to extract everything from the 
NestingComponents component related to the user  
message, including the state and curly braces, 
and copy it into the UserMessage component.  
Of course, this is a functional 
component which doesn't have any state,  
so instead, like I said just a moment 
ago, we're going to pass in whether the  
user is logged in as a prop. So I'll change 
this.state.isLoggedIn to props.isLoggedIn.
So that's it, our user message component is 
complete, and now we just need to nest it  
within the parent component. To do that let's 
go to NestingComponents.js and at the top,  
import UserMessage from ./UserMessage. Notice 
we're leaving off the "components" part here  
because these two components exist in the same 
directory, so we just need to import the component  
from the relevant file. This UserMessage 
refers to the function that we exported,  
while the latter one refers to the 
filename the function exists in.
The next step is to render the component here in 
the render method. To do that we just include our  
component that was imported as a custom JSX 
element, and that's it! The final step then,  
is to pass whether the user is logged in down into 
this component as a prop, and that's easy - all we  
need to do is add the prop called isLoggedIn 
and set its value to this.state.isLoggedIn.
When I save this, everything should work as 
before. What's happening now is that when I change  
the state in the parent component, the isLoggedIn 
property is passed down to the child UserMessage  
component as a prop, and the child renders 
the appropriate content based on that prop.  
You could do this with more than one prop 
too, or even more than one component.  
Many react applications have parent container 
components that have lots of state properties  
that get passed down to various children 
as props in exactly this fashion.
Let's quickly repeat the same process 
for the other bit of data here.  
Take 5 minutes yourself to repeat this process 
to extract the other bit of JSX here into the  
UserData component. When you’ve got your component 
done, import it and include it in place of the  
JSX like we did with the other one. Don’t forget 
to give your component any props it might need.  
Pause the video now and try to work through this 
on your own and then we’ll go over how to do it.
Welcome back! Let’s go through 
my solution step by step:  
I’ve used the rfce snippet to create 
a functional component in UserData.js,  
then given it some props. I copied the h1 
into it and changed this.state to props.
Then, back in the parent component, I’ve 
just imported the UserData component,  
and included it in the JSX, passing the 
isLoaded property down from the state so we  
can render it as a prop in the child component. 
Changing the state properties in the parent  
now results in those properties being 
passed down to the children as props,  
and the children, each time they’re 
given new props, rerender accordingly.
This process of building a component,  
then realizing that part of it might be better off 
extracted into its own component, and continually  
refactoring your code to create smaller and 
smaller components is common in React development.
In this video, we passed some state 
properties down to the children as props,  
but you can actually pass anything 
you want as props: strings,  
numbers, functions and methods, even other 
components. The process we used in this video  
allowed us to update a child component 
by changing something in the parent.
It’s also possible to do the opposite: 
updating a parent component from a child.  
You can do it using this exact same technique, but 
instead of passing a simple boolean property like  
isLoggedIn or isLoaded, you’d pass down 
an event handler from a parent to a child,  
and then call the event handler from the 
child to change something in the parent.  
We’ll look at the exact details of 
how to do this in the next video.
------ A6PbfsyBLi4 ------
In the last video you learned 
about nesting components,  
and more importantly, how a parent component 
can pass props down to its children.
In this video, you’ll learn how to pass 
a method, specifically an event handler,  
from a parent to a child component, which will 
allow you to update the parent from the child.
For this video I’ve created two new components: 
MethodsAsPropsParent, which is a class component,  
and MethodsAsPropsChild, which is a functional 
component. For convenience you can find the code  
for these two components linked on this page. 
Functionally these components are identical  
to the NestingComponent and UserMessage 
components in the last video. When I change  
the state in the parent component, the child 
component renders the new content. Make sure  
this works before continuing because without it 
working the rest of the video won’t work either.
So what’s the task at hand here? Well, one of the 
design specifications in React is that data should  
only flow down the DOM tree. In other words, we 
should only ever be making changes to children  
from their parents, and not the other way around. 
There are, however, sometimes situations where we  
might want to be able to update the state of 
a parent component from one of its children,  
perhaps in order to force it to pass 
new props down to a different child.  
Luckily there’s a pretty easy way 
to do it in case you ever need to.
So what are the ways we could update the state 
here in the parent component? One way, of course,  
would be to create a button in the parent 
component and write a click handler like we’ve  
done in previous videos. This would work, but the 
button in question should really be part of the  
child, since it's part of what would be rendered 
depending on whether or not the user is signed in.  
It should be rendered along with 
the ""Please sign in"" message,  
based on the props passed in. So let's 
begin by creating a button with the text  
""Sign in"" in the child component. Don't 
forget React only wants to return one  
element from any component too, so we'll 
need to wrap these two elements in a div.
Now we need a click handler for this button, but 
there's a problem. This component is functional,  
and thus has no state so we can't change the 
isLoggedIn property from inside this component.  
Whether or not the user is logged in is passed 
down from the parent component as a prop,  
so we need to call back out 
to the parent and say hey,  
update your state so isLoggedIn is true, and then 
rerender this component with the new props. 
To do that, we have to create the click handler in the 
parent, and pass it down to the child as a prop.
Let's go to MethodsAsPropsParent and create a 
click handler. Since it's going to be a sign  
in handler, I'll call it handleSignIn, and it 
will be an arrow function so we don't have to  
worry about binding it. In the function, I'll 
call this.setState and set isLoggedIn to true.  
I also want to log this to the console 
here, and you’ll see why in a minute.
So we've got our click handler, we've got a 
button, now we just need to connect them together.  
To pass this handler down to the child as a 
prop, we can do it just the same as with the  
isLoggedIn prop. I'll create a new prop here 
called handleSignIn, and I'll set its value equal  
to this.handleSignIn. Remember, we don't want 
parentheses here since we are not actually calling  
the function, we're just passing the function 
itself down to the child so we can use it there. 
Finally, in the child component, I’ll add the 
onClick attribute and set its value equal to  
props.handleSignIn. Now, whenever the sign in 
button is clicked, the child component will  
execute the handleSignin function defined in the 
parent, updating the parent’s state and setting  
isLoggedIn to true. If you look in the console 
when clicking the button, you'll see that even  
though the button exists in the child component, 
this refers to the MethodsAsPropsParent class.  
That’s a key thing to recognize because it 
means that we can call out from the child  
to change things in the parent, and that 
means we can cause other children to rerender.
There's just one small issue with this 
and that's that once we're signed in,  
we don't have a way to sign out. 
At this point, pause the video and  
take 2-3 minutes to see if you can fix 
this yourself by creating a new method,  
passing it as a prop, and then calling 
it in the child in the appropriate place.
Alright welcome back, so 
luckily this is an easy fix.  
What we need to do is copy the button from the 
sign in content, paste it in the other content,  
and just change its click handler and text to sign 
out. Then in the parent, we can copy the click  
handler we created and change it to sign out, 
setting isLoggedIn to false. Finally, we can pass  
this new handler to the child as well. With that 
done, we can now sign in and sign out of our app.  
Of course, it’s possible to make a single method 
handle both sign in and sign out. If you’d like  
to, you can try to refactor this yourself to make 
that work, but it’s not a requirement to move on.  
The solution is linked on this page if you do 
want to give it a try and then check your work.
Passing methods as props is a common way to handle 
updating the state of a parent component from a child.
If you find yourself doing this a lot 
though, it might be an indication that there's  
a better way to do things. For example in this 
scenario, It probably makes more sense to just  
make the whole child component stateful and define 
the sign in and sign out functionality there instead.
This would keep the component totally 
independent of the parent since it wouldn't  
depend on the parent's state anymore. For the 
purposes of this video I wanted to do it this way  
not only to show you how to pass methods as 
props, but also to help you understand that like  
any other language, there are usually multiple 
ways to solve the same problem with React.
Over the last several videos you've learned how 
to create functional and stateful components,  
how to work with props and state, 
how to handle events in React,  
how to conditionally render content, nest 
components within each other, and pass methods  
as props. In the next video, you'll take on a 
small challenge, allowing you to put all this  
knowledge to the test by building a more complex 
user interface that has some interactivity.
------ nVdRAACN1KY ------
When building web applications, 
especially data-driven applications,  
a common requirement is rendering lists of items. 
For example, in the mini challenge from lesson 2  
you created a bookstore with three books in it.
In that case, it wasn't a big deal to just copy  
and paste the code a couple of times and fill in 
the props. But what if you had a bookstore with 1,000 books?
You would need to copy and paste that 
code 1000 times. Further, if you changed the name  
of one of the props, or the name of the component, 
you would have to make the change 1000 times in  
your code. Wouldn't it be nice if, instead, you 
could just feed in a list of books with their  
respective titles, authors, page numbers and 
cover photos and render all of them in a loop?  
Luckily, React makes this type of automation 
easy, and you'll learn how to do it in this video.
You’ll learn how to render items from a 
simple array, how to render JavaScript objects  
that have multiple properties, and even how 
to render multiple components in a loop.
Because React relies heavily on JavaScript, we can 
use the map() method to iterate over an array of  
items or an object and its properties. You might 
recall from the advanced JavaScript module that  
the map() method can execute a function on each 
item, and returns a new array containing the modified items. 
In React, usually this means taking an array 
of items, like our books in this example,  
and returning those items wrapped 
up in some sort of HTML structure.  
React developers often use map() to 
create ordered or unordered list items,  
table rows and cells, and rows 
and columns in a Bootstrap grid.  
Basically, anything in HTML that would be 
repetitive can be rendered using the map method.
Let's begin with a simple example. I’ve 
already created a new functional component  
called RenderingLists.js and imported it and 
included it in App.js. Inside it, I'll create  
a simple array of books called bookList. In the 
array will be three books: To Kill A Mockingbird,  
The Great Gatsby, and The Catcher In The Rye.
In the return statement of our component let’s  
open a set of curly braces, indicating we’re 
about to use some JavaScript. My goal here is  
to iterate over our list of books and render 
a heading element for each one. We can start  
with bookList.map(). Now we need to think about 
the function we want to execute on each book in  
the list. It’s pretty simple, we just want it 
to take in a book and return an  element.  
If you’d like, this is a good place to pause the 
video and take two minutes to try to do this on  
your own, then come back to see the solution.
Alright, hopefully you 
paused the video and were  
able to finish that on your own. If not, here’s 
how to do it: I'll create a new arrow function  
that takes a book as a parameter, and returns 
an H2 element containing the book. Now I can  
save the file and see each book rendered in the 
UI. So what is happening here, is the map method  
is iterating over each book in the booklist, and 
returning each book wrapped up in an h2 element.  
This is functionally identical to the for loops 
you’re familiar with from vanilla JavaScript. 
Now let's look at how to do this with something 
closer to what we had in the challenge  
where you created a bookstore. I'll create a new 
array at the top here called books, and inside it  
create three objects. Each one will have the 
book's title, author, and number of pages.  
Now, in the return statement I'll add a horizontal 
rule and then open a new set of curly braces.  
Once again, I'll use the map method to iterate over 
books, and pass it a function to execute on each book.
This time, for each book I want to return 
the following structure: a div containing an h5  
for the book title, a paragraph for the author, 
and a paragraph for the number of pages.   
Once again, pause the video here and take five minutes 
to try to complete the function on your own. 
Alright, welcome back once again. So in this 
second example, book refers to the object in the  
array of books, so each property can be accessed 
using standard javascript dot notation. So my map  
function returns a div with the h5 and the two 
paragraphs, and each book property is injected  
using dot notation in the JSX. In the UI, you can 
see each book along with its author and number of  
pages being rendered successfully.
Finally, sometimes when you render  
content like this you might realize it’s 
better to do it in a separate component  
in order to keep your code clean. As a final 
challenge for this video, I’d like you to  
extract the 2nd bit we’ve just written here into a 
separate component called Book.js. Book.js should  
be a functional component that takes the book as a 
prop and returns the same structure as shown here.  
When you’ve written the Book component, use the 
map method here in RenderingLists.js to map over  
the array of book objects and for each one, render 
the Book component, passing it the book as a prop.  
Pause the video for five minutes now and give 
this a shot, then come back to see the solution. 
Alright, so this one was a little more challenging 
so don’t feel bad if you couldn’t figure it out.  
Let's review how it works. 
First, here’s the book component.  
I’ve set a constant called 
book equal to props.book.  
Then I'm importing the book component from 
book.js at the top of RenderingLists.js.   
When I call books.map(), the “books” here is referring 
to the array of objects at the top of this file.  
Inside the arrow function, we're 
saying for each book in that array,  
render a  component, which 
takes a property called book,  
and pass the object we're working on, for 
example, To Kill A Mockingbird, as the value.  
The book component then 
receives this object as a prop,  
and we just set it equal to book here so 
we can use it in the return statement. 
So in this video we've covered how to render 
items from a simple array, how to render items  
with properties, and how to render external 
components by passing array items as props.  
There are actually several more ways you could 
clean this code up, but the important part is  
that you understand the concept of using the 
map method to render repetitive HTML and JSX,  
rather than copying and pasting it. The map 
method is used constantly in React code,  
so if you ever find yourself copying and 
pasting repetitive code, remember there's  
a good chance you could be using map.
In the next video, you'll learn about  
a small problem with what we've 
done here, and how to fix it.
------ 5kCIuPDwHZA ------
In the last video, you learned a few 
different ways of rendering lists in React. 
In this video, you’ll learn about a subtle  
problem with the way we rendered 
those lists, and how to fix it.
On the surface, everything appears to work 
fine, but as with many things in React,  
things are not always what they seem. If 
you open the console and refresh the app,  
you'll see a warning: Each child in a 
list should have a unique "key" prop.
What this is telling you is that for each 
element that you render in a list, in our case,  
for each book, it must have a prop called 'key' 
which identifies it uniquely, like a primary key  
in a database. This unique identifier is used by 
React to keep track of which elements need to be  
rerendered whenever the component is updated.
Let's first solve the problem, and then we'll  
talk about why this requirement exists. In 
RenderingLists.js, I'm going to add a new  
prop called key to this h2 element. The 
key needs to be unique so that React can  
identify if that specific element has 
changed when it performs updates to the UI.
In this case, the title would be a good thing 
to use for the key since we know, at least in  
this array, that the title is unique. So for this 
one, we can just say key={book} in curly braces,
since the first array is just an array of simple 
strings. The key can really be anything you want  
though, as long as it's unique. I'll also use the 
title as the key for the second and third lists,  
but for both of these I'll need to specify it 
with book.title, since these ones use the list  
of objects. If I save that and take another 
look at the console, the warning is gone. 
Before we get into why this requirement exists, 
take special note that even though these first two  
calls to the map method do not render a React 
component, they can still take this special  
prop called key, and in fact, it's required 
that you pass it whenever rendering lists  
of items whether they are divs, headings, 
paragraphs, components or anything else.  
As far as which element the key goes on, always 
put the key on the outermost element that will  
be repeated, for example we put the key 
on the div in the second example here,  
not on any of the elements inside it. Also, note 
that if you do pass the key prop to a component  
like we're doing here in the book component, 
you cannot access the key inside the component.  
If you try to access the key inside the book 
component, React will alert you that if you need  
to access that same value inside the component, 
you should pass it as an additional prop. The  
key prop is reserved for React itself, so you 
should never use it as the name of a regular prop. 
Now let's talk about why keys are needed in the 
first place. In React, UI updates are made by  
comparing the existing DOM tree line by line 
to a new virtual DOM tree which React keeps  
track of. Once the comparison is complete, React 
updates the relevant nodes. So, if you consider a  
situation where we have a list of items and we 
want to add a new item to the end of the list,  
React compares the two lists side by side, sees 
that the first two list elements are the same,  
ignores them, and inserts the new 
item at the end. This is no problem. 
If, however, you were to insert an item at the 
beginning of the list, React will change all  
three items because when compared side by side it 
appears that both of the first two have changed,  
and additionally another has been added to 
the end. This causes React to update all three  
elements when it really only needed to update 
one. This is not an issue when there are only  
three elements, but when working on a large 
web application with thousands of elements,  
this tiny issue is exacerbated into a gigantic 
problem that can slow your application to a crawl. 
To alleviate the problem, React asks you to 
provide a unique key whenever creating lists  
of elements, so that it can keep track 
of which ones have actually changed.  
Rather than using the element's position in 
the list to identify it, React uses the key,  
which ensures it's always comparing the 
correct elements as long as the key is unique.  
This is also why it’s so important to make 
sure that the key you choose is in fact unique. 
I want to finish this video with one last 
important warning. When studying React code and  
many tutorials and videos online, you are bound 
to come across developers who use another form  
of the map method, which uses a second parameter 
called index. This parameter represents the index  
of the array for each iteration of the map method.
For example here, we can render it as 0, 1 and 2.  
You might be tempted to use this index as a key if 
you don't have an obviously unique value already.  
Make a note that you should only do this if your 
list meets all three of the following conditions.
First, it must not already have 
any sort of unique ID or value in it. If  
it does, use that as the key instead.
Next, the list of elements
you’re rendering must be static.  
If anything will ever be added to or removed 
from it, using the index as a key will leave  
React incapable of accurately keeping track 
of which element is which. Finally, your list  
must never be sorted or filtered. If there is 
any intention to ever sort or filter the list,  
using the index as the key will 
throw off the sorting and filtering.
If you're in a situation where your list 
doesn't meet all three of these conditions,  
but you still don't have a unique key, you 
can either derive one from one of the existing  
properties, or look into one of many available npm 
packages that exist for exactly that situation. 
So, whenever rendering lists of items in React, 
always make sure every item has a unique key prop,  
and in general, avoid using the index as the 
key unless you have absolutely no other option. 
In the next video you'll start 
learning about the component lifecycle,  
a very handy concept you can use to 
better control your React applications.
------ CxQ3vtaiBoo ------
In the previous video, you learned how to use the 
reserved key prop when rendering lists of items  
in React components. At this point, you should 
have a good idea of how to create different  
types of React components and how to work with 
state and props to add some interactivity.
In this video, you’re going to learn how you can 
use something called the component lifecycle to  
add more advanced interactivity, and control 
exactly how your components render and change. 
In React components there are three primary 
processes: mounting, updating and unmounting.  
Mounting refers to when the component is 
initially placed into the DOM. Updating refers  
to when something has changed, such as props or 
state, and the component needs to be rerendered.  
Unmounting refers to when the 
component is removed from the DOM.  
Components are constantly mounting, updating and 
unmounting as users use your application, and this  
process of mounting, updating and unmounting 
is referred to as each component's lifecycle.
So far, we've only executed code based 
on user interactions with our components,  
like clicking buttons. If you want to 
execute some code automatically at a  
specific point in the component lifecycle, for 
example, right after it's placed in the DOM,  
React provides a number of built in methods to 
meet your needs. The three primary methods you'll  
see are componentDidMount, componentDidUpdate, 
and componentWillUnmount. componentDidMount  
is executed just after the component is mounted,  
componentDidUpdate is executed every time the 
component updates, and componentWillUnmount is  
executed just before the component unmounts. 
Here's a quick preview of each of them.
In this Gitpod template adopted 
from an example in the React docs,  
I've created a clock and utilized the three most 
common component lifecycle methods to handle  
updating the clock every second and to log some 
information to the console about what's happening.  
If you'd like to make a copy for your reference 
or just want to follow along and experiment on it,  
just go to the template repo linked on this page 
and follow the instructions in the readme.   
We won't be doing any coding here though, I'll just 
briefly explain the flow of the code, and then  
we'll look at the console to see it in action.
The first time the component is rendered,  
in other words, when the page is initially loaded, 
the constructor is called and sets everything up.  
This takes care of creating a new date object in 
the state which is what you see keeping track of  
the time in the preview window. Next, the render 
method is called, which returns the JSX you see in  
the browser. After the render method has executed, 
the component is considered mounted and that's  
when componentDidMount executes. This method 
executes every time the component is mounted,  
but not when the component is updated, since 
that doesn’t cause the component to be unmounted  
and remounted. In this component, 
the componentDidMount method sets up  
a timer that executes this.tick() every 
1000 milliseconds, or once per second. 
Each time the tick method is executed, the 
component's state is updated using the setState  
method to reflect the new date. At this point, 
the component has new information in the state,  
and so it must rerender. Here, 
the render method is called again  
and then componentDidUpdate is called. Neither the constructor nor componentDidMount is called here,  
since the component has already been 
mounted and is just being updated.
The component stays mounted until 
something explicitly unmounts it,  
like the user refreshing the whole page, clicking 
a show/hide button, or a parent  
component rerendering, which removes 
it from the DOM and then remounts it. 
Finally, if the component does need to be removed 
and replaced in the DOM, the componentWillUnmount  
method is called just before the component 
is unmounted, in order to give you a chance  
to execute any cleanup functions that are needed. 
Some examples of cleanup functions that you might  
want to run before unmounting a component include removing event listeners, resetting intervals,  
stopping timers or cancelling active network 
requests. In this case, the componentWillUnmount  
method clears the timer so that it doesn't keep 
trying to call the tick method and update the  
state of a component that no longer exists.
So, to quickly summarize, when the page  
is initially loaded, or whenever the 
component is unmounted and remounted,  
the constructor is called, then the 
render method, and then componentDidMount.
On updates, the constructor and 
componentDidMount are skipped  
and React just calls the render 
method and then componentDidUpdate.
Finally, whenever the component unmounts, 
first componentWillUnmount is called,  
then the component is unmounted, and if it needs 
to be remounted then the whole cycle starts again. 
If I open the console and 
refresh the preview window,  
I can see this cycle repeating. Notice we 
start with the constructor being called,  
then the render method, and 
finally the component is mounted.  
Then, we see the render method repeatedly being 
called again Each time the component updates.
If I make a change to the code and save the file,  
you'll see the component unmount and remount 
as well as the constructor being called again.
If I uncomment the code in 
componentDidUpdate and the tick method,  
you'll see each time the component is 
updated as the tick method is called.  
I can also unmount the component to clear 
the interval and remove the component,  
when the 
component is remounted, the process begins again.
These lifecycle methods are quite useful for 
a variety of things, in particular things like  
fetching data to be displayed in a component. If 
you need help remembering them, there's a nice  
cheat sheet from the React docs linked on this 
page which you can bookmark to use as a reference. 
Over the next few videos we'll go 
over each of these methods in detail.
------ nDtD0w7PX6E ------
In the last video you saw a brief introduction 
to the component lifecycle methods:  
componentDidMount, componentDidUpdate, 
and componentWillUnmount.
In this one, let's look at the 
componentDidMount method in more detail.  
For this video I've created a new class component 
called LifeCyclesCDM.js which returns an h1 element  
that says lifecycles. I’ve imported 
and included it in App.js. I’ve also created  
a child component called LifeCyclesCDMChild.js 
which we’ll use toward the end of this video.  
You can just copy and paste the code into it from 
this page and I’ll explain it when we get to it.
As you know from the last video, componentDidMount 
is the method that’s called right after the  
component is first added to the DOM, and will not 
be called again unless the component is unmounted  
and mounted again. One common thing this 
method is used for is data fetching,  
which basically means getting 
some data from an outside source,  
like an API or a database. Since we haven't 
learned about data fetching in React yet, we'll  
simulate some in this component. I'm going to 
start by creating a constructor and adding a data  
property to the state with the value “loading”. 
I'll switch out the h1 here for this.state.data.
Now we'll need a getData method. Inside it, to 
simulate getting some data I'm just going to use  
a setTimeout function that calls this.setState to 
change data to loaded after 3 seconds.   
Remember, the setTimeout method takes a function 
and a time as its parameters so all I'm  
doing here is passing in an arrow function 
and 3000 milliseconds. The getData method  
we’ve just written won’t do anything on 
its own, so we need to call it somehow.  
In a real scenario, you’d probably want to get 
the data as soon as possible after the component  
is mounted, so the perfect place to call the 
getData method would be in componentDidMount.
With that in mind, let's add the componentDidMount 
method. Inside it I'm just going to call  
this.getData(). So this way, once the component 
is mounted, the getData method will be called,  
and three seconds later the state will be updated 
and the data will be loaded. This is a common  
pattern since many React components will depend on 
making an HTTP request to an API to get some data.  
The request might take a second or two, so rather 
than wait for the data before loading the page,  
we can instead render an empty 
version of the component,  
call this method as soon as it’s 
mounted, and once the data comes back,  
set the state to contain the new data which 
will then be rendered in the component.  
If you save all that and run the app, you’ll 
see the process is working as expected.
Now that our programme works, let's use that 
handy clg snippet to add some console logging here  
to see the exact process that happens and when 
each method is called during the lifecycle of  
this component. In the constructor I'll 
put “constructor called”, then in getData  
I'll log both when the method is called 
as well as when the data is fetched  
and the state is about to be updated. I'll 
also add a message in componentDidMount  
and in the render method so we can 
see when they are being called.
With that all done, let's open the 
console and refresh the preview window.  
As expected, we first see that the 
constructor is called, then the render method,  
and finally componentDidMount which calls 
the getData method. After three seconds,  
the “data fetched” message is 
logged and the state is updated,  
causing the render method to be called again 
as the component rerenders with the new state.
I'll refresh one more time so you can see 
it again. First constructor, then render,  
then componentDidMount which calls 
getData, then there's a three second delay,
and then “data fetched” and a rerender.
If you look in the LifeCyclesCDMChild component now, 
you’ll see it’s a carbon copy of the parent 
component we’ve just created, but everything is  
updated to include “child” throughout. This is 
just so we can tell it apart from the parent.  
Now I'm going to import and include this 
child component in the parent component.  
What I want you to understand by doing this is how 
componentDidMount behaves with child components.
Before you continue watching this video, 
I want you to pause here, run the code,  
and take five minutes to study the messages 
being logged in the console. See if you can  
determine the order in which all the methods in 
each component are being called as the code runs.
There’s a slightly different process that 
happens when working with child components,  
so I want you to see if you can figure it 
out before I explain it in the next section. 
Welcome back. If you look at 
the console and refresh the  
page you'll see a different process 
happening from what we saw before.  
We still see the parent constructor and render 
method called, but then we take a little detour.
Since the render method is now rendering another 
component, the child's constructor is called,  
followed by its render method, 
its own componentDidMount,  
and its own getData method. Once this is 
done, the flow returns back to the parent  
and the parent’s componentDidMount method 
is called, followed by its getData method.
Finally, once the child's data has been fetched, 
we see it there in the console followed by the  
child rerendering, then the parent's data 
comes back, causing the parent to rerender,  
which causes the child to rerender one more time.
If this seems confusing, it's ok. The key thing 
to remember is that when you have a component  
that renders child components, the parent's 
componentDidMount method will not be called  
until all its children are mounted. Additionally, 
rerendering the parent will cause all its children  
to rerender as well which is important to know 
because if you have a parent with a lot of  
children, rerendering the parent might be slow, 
since it also has to rerender all its children.  
In the future, you’ll also learn ways of 
preventing these unnecessary rerenders, but for  
now just remember the simple point that parents 
and children are closely connected in these ways  
when it comes to rendering and mounting.
That covers the important aspects of  
componentDidMount. It will start to make more 
sense as you build more complex applications  
and you find that you need it. The key things 
I want you to take away from this video  
are when the componentDidMount method is 
called, how you can use it to execute some  
logic as soon as a component is mounted, and how 
it behaves with respect to parents and children. 
In the next video, we'll look at the 
componentDidUpdate method in more detail.
------ MhPzqQET3so ------
In the last video we discussed the 
componentDidMount method in more detail. 
In this video, let's do the same 
for componentDidUpdate which is the  
method that is called whenever a component 
rerenders due to changes in props or state. 
For this one, I've created two new class 
components called LifeCyclesCDU and  
LifeCyclesCDUChild, and I've imported and used 
LifeCyclesCDU in app.js. This component has a  
single state property in the constructor called 
Greeting and it's set to Hello, and that greeting  
is rendered in the render method. What we're 
going to do is write a method to update this  
state property and then add the componentDidUpdate 
method to see how the update lifecycle works. 
First let's create a new method as a 
class property called updateGreeting.  
This method will be an arrow function 
which calls this.setState. I'm going to  
use the function form of setState so that I can 
toggle the greeting between hello and goodbye  
by looking at the previous state. So, arrow 
function which takes prevState as a parameter,  
and returns the new state object which will 
have greeting set to a ternary conditional.  
If prevState.greeting is hello, we'll 
change it to goodbye, and vice versa. 
Now let's add a button to the render method. 
I'll give it the text “update greeting” and  
the onClick attribute will be set to our 
method, this.updateGreeting in curly braces.  
If I click the button now in the preview window, 
the greeting changes, so our button is working.
Now I'm going to add the 
componentDidUpdate method and inside it  
I'll just log “component updated”. If I 
open the console and click the button,  
the message is logged to the console 
so we know the method is being called.
I'm also going to add a message to the 
constructor, the update greeting method,  
and to the render method as well. Now I’d like you 
to save this and pause the video for 5 minutes,  
refresh the page, click the button again, 
and take a look at the console output.  
See if you can determine the order in 
which all the methods are executing,  
and see if you can understand the 
update process before I explain it. 
Welcome back, hopefully you were able to 
decipher most of what’s going on. As usual,  
the constructor is always the first method to be 
called, followed by the render method. We don't  
see the componentDidUpdate method called yet, since 
the component has just been mounted for the very  
first time. If I click the update greeting button, 
we see the update greeting method called, then the  
render method, and finally componentDidUpdate. 
It's important to recognize the component was  
not unmounted here, it was simply updated, and 
that’s why the constructor wasn't called again.  
Each time I click the button, I see the same 
process. First the method we wrote is called, then  
the component is rerendered since the state has 
changed, and finally componentDidUpdate is called.  
This method is a good place to run code that you 
want to happen each time the component is updated. 
Now let's see how it acts when we 
add a child component into the mix.  
Just like in the last video, this component 
is just a copy of the parent component with  
a different name and different 
logs so we can tell it apart.  
You can find the code for it on this page if 
you want to copy and paste it. Now I'll head  
back to LifeCyclesCDU and import and include the 
child inside the parent. Again, pause the video  
now and run the code to see if you can determine 
the order the code will run before we continue.
Welcome back, let's open the console 
again and take a look at the difference. 
Just like with componentDidMount, the 
parent constructor is called first,  
then the render method, and that method 
renders the child component so we then see  
the child constructor and its render method 
called. If I update the child greeting by  
clicking the bottom button, notice that the only 
update method that gets called is the child's.
If I click the parent's update button 
though, both the parent's update method  
and the child's are called, even 
though nothing changed in the child.  
Because the parent had to rerender it, it's 
considered to be updated. Just like with  
componentDidMount, this is important to remember 
because if you have a lot of children, updating  
a single parent will cause all the children to 
update and this can slow your application down.  
If that happens, it's an indication that you 
might need to rethink your design and make  
your components more independent of one another.
One last note, sometimes you may want to perform  
the code in the componentDidUpdate method only if 
a specific prop or state property has changed.  
For example, maybe we only want to change the greeting 
if some other state property has also changed.  
In that case you can access the previous props and 
previous state in the componentDidUpdate() method  
by passing them in as parameters similar to how 
you do it in the setState method. To demonstrate,  
let's add a prop to the child component here 
by passing in the parent's current greeting.  
Then I'll head to the child component and add 
prevProps and prevState to the componentDidUpdate method.
I'll log both of those to the console. 
Additionally, if I wanted to do something only  
if the parent greeting has changed, I now have 
the ability to say if prevProps.parentgreeting  
does not equal this.props.parentGreeting, then let's 
log that the parent greeting has changed.
Now when I click the child's update button, in 
the console we only see the first three lines,  
but if I click the parent's update button, 
the conditional code executes as well  
since the parent greeting has changed.
So in this video we’ve covered the finer  
details of the componentDidUpdate lifecycle 
method. The key things to remember are: first:  
the componentDidUpdate method is called every 
time the component updates, whether the update  
was caused by a change in props, a change 
in state, or a parent component rerendering.  
Second, a child updating will not cause a 
parent to rerender, but a parent updating  
will cause its children to rerender. Third, 
if you need to run the componentDidUpdate code  
under specific conditions related to the 
previous props or state of the component,  
you can access prevProps and prevState by 
passing them into the method as parameters. 
There's one more method you should 
know well before we move on,  
and that's the componentWillUnmount method. 
We'll talk about that one in the next video.
------ 3-7HpkIE7u8 ------
In the previous video, you learned 
some of the finer details of how  
componentDidUpdate works in React.
In this video, we're going to discuss  
the last of the commonly used component 
lifecycle methods: componentWillUnmount.
For this video, I've created 
two new class components:  
LifecyclesCWU, and LifecyclesCWUTracker.
The LifecyclesCWUTracker component just renders 
a single H1 element that says tracking mouse  
along with a paragraph showing the X and Y 
position of the mouse. The other component  
renders the LifecyclesCWUTracker component as 
a child, assuming this.state.visible is true.  
It also contains a button to show/hide the child 
component, which we’ll add some functionality to  
in a few minutes. I’ve included the code for these 
components on this page for you to copy and paste,  
so pause the video here, create 
the components in your workspace,  
and then import and include the parent 
component, LifeCyclesCWU in App.js.
With those components created and working as 
expected, let's begin in the LifecyclesCWUTracker component.
It’s not important to understand 
exactly how this works, but at a high level,  
when the component mounts, I’ve attached an 
event listener to the mousemove event which,  
each time it’s triggered, will call the trackmouse 
function. The trackmouse function updates the  
state with the new X and Y coordinates. In this 
way, as soon as the component is mounted, the  
event listener will start listening to mousemove 
events and tracking the mouse, logging to the  
console that the mouse has moved and also updating 
the UI. Let's open the console and take a look.
As expected, we see the "mouse moved" message 
logged to the console and the position is  
updating accordingly in the UI. Everything is 
working as expected. Now, I'm going to go to the  
LifeCyclesCWU component and add some functionality 
to this button, so we can toggle the display  
on and off. I’ve already written the event 
handler, toggleDisplay, which is an arrow  
function that calls this.setState using a function 
to set the visible property equal to the opposite  
of the previous state. Remember, we always want to 
use this pattern whenever the state update depends  
on the previous state, which in this case it does. 
Simply put, this code will just toggle visible  
between true and false based on whatever it was 
in the previous state. To make the button work,  
all I’ve got to do is give it an onClick handler 
for our function, this.toggleDisplay. Now we  
can click the button to toggle the display on and 
off. Let's open the console and refresh the page.
At first everything seems fine. The console 
is logging the mouse movement event,  
the UI is updating and everything is working as 
expected. Now I'm going to toggle the display  
and we see that the mouse tracker component 
is now hidden. When I move the mouse though,  
I get a warning in the console: Can't perform 
a react state update on an unmounted component. 
This is where componentWillUnmount comes into 
play. If you read the rest of the warning,  
you'll see it says that to fix it, we need to 
cancel all subscriptions and asynchronous tasks  
in the componentWillUnmount method. What's 
happening here is when we toggle the display  
in the parent component, it actually removes the 
mouse tracker component from the DOM completely,  
which unmounts it. However, the event listener 
from that component is still there, listening  
for mouse move events, and trying to update the 
state of the mouse tracker component, which has  
been unmounted. So this warning is telling us that 
we're trying to update the state of a component  
that is no longer mounted and thus to React, it 
no longer exists. To fix it, we need to remove the  
event listener just before the component unmounts, 
using the componentWillUnmount lifecycle method.
To do this is quite simple, all we've got to do is 
add the componentWillUnmount method to the tracker component.
Inside it, I'll just log 'unmounting', 
and then call window.removeEventListener  
on our mousemove event. Now, whenever 
the component is about to be unmounted,  
first the listener will be removed from the 
window so it no longer tries to update the  
state of the unmounted component. 
Let's save this and test it out.
Now, everything works the same as 
before, but when I toggle the display  
I see the message that the component is 
unmounting and then the event listener is removed.  
With the display off, I can move the mouse around 
and there is nothing logged to the console,  
and when I toggle it back on the event listener 
is added again in the component did mount method.  
This is the main usage of componentWillUnmount. 
Anytime you need to do some cleanup stuff like  
removing event listeners, resetting intervals, 
stopping timers or cancelling network requests,  
you should do it in componentWillUnmount.
This is the last of the commonly used 
component lifecycle methods in React.  
There are actually several other lifecycle 
methods which you can read about in the  
React documentation if you prefer, but they're 
classified by React as rarely used, so for now  
you don't need to concern yourself 
with understanding them in detail. 
A couple final notes about 
component lifecycle methods. 
When using these methods, you should always 
be careful if you use them to make changes to  
the state. Remember that changing the state 
will always cause a component to rerender,  
so if you are not careful about updating 
the state in these lifecycle methods  
you can cause what's known as a 
rendering loop. In a rendering loop,  
a lifecycle method changes the state 
or props which causes a rerender,  
but then the rerender causes the lifecycle method 
to be called again. This creates an infinite loop  
which can crash your application. Don’t worry 
about this too much, as React has some safeguards  
that prevent it from crashing your whole browser, 
but it’s something to be aware of anyway.
Second, you might have noticed that all these 
methods were created using class components  
and we didn't talk about 
functional components at all.  
That's because functional components, 
as you know them currently,  
don't have lifecycle methods. These methods 
are only available when using class components.
In a future lesson, you'll learn about hooks, 
which eliminate the need for class components  
almost entirely and allow you to duplicate 
the component lifecycle functionality  
in functional components.
Before we get to that though,  
we've got one more subject to go over 
and that's form handling in React.  
We'll get started on that in the next video.
------ b86tJpM8Jn8 ------
In the previous video you learned about the last of the component lifecycle methods, 
componentWillUnmount.
In this video, you’re going to learn the basics of how forms work in React. To understand forms in React there are two  
new terms you need to know, controlled 
components and uncontrolled components.
Controlled components 
are form components or  
elements whose values are maintained 
and managed by the state in React.
Uncontrolled components, on the 
other hand, are form components or  
elements (such as a text box) whose values 
are maintained and managed by the DOM.
To understand both of these concepts, let’s 
build a simple form and use it to demonstrate. 
To begin, I’ll create a new file called 
ControlledForm.js, and inside it,  
I’ll use the snippets rce and rconst to create 
a new class component and give it a constructor.  
You should be pretty familiar 
with doing this at this point  
so I won’t spend much time here. Let’s 
get right into creating the form.
In the main div, I’m going to 
create a new form element.
This form will be pretty much 
identical to what you’re used to in HTML.  
I’ll create a label for the first field, 
which will be for your name. Now let’s  
make a standard text input to hold the user’s 
name, and a submit button to submit the form.
Now, we need to link up the label and 
the input by giving the input an ID  
and the label a for attribute. Remember that 
in JavaScript, though, for is a reserved word,  
so for this label we need to use the htmlFor 
attribute and make sure that it’s camel-cased.  
We also need to give the input a name 
attribute for when it’s submitted.
It’s been a while since we talked 
about this, so if it seems unfamiliar,  
return briefly to the JSX introductory 
video and pay attention to the ending where  
we discussed the differences between 
HTML attributes and JSX attributes.
With the form created I’m now going to go to 
App.js and include the ControlledForm component.  
Now when I run the app, the form is rendered 
in the preview window and works as expected.
If you open the app in a new tab, type 
something into the form and submit it,  
you’ll find that it already works. By default 
it submits a GET request, attaching the value  
of the “name” input to the end of the URL. 
Unfortunately though, this refreshes the page,  
which is one of the things we are trying to 
avoid in React. We want the component to be  
able to function independently, without 
changing the rest of the page or the app.  
This form is considered to be uncontrolled, 
since the DOM is controlling everything it does. 
React is rendering the form, of 
course, but the submission is handled  
by the DOM which causes the page to refresh. 
Now let’s learn how to give control to React. 
The input field in our form, if you think about 
it, is sort of maintaining its own internal state.  
The state of the input at any given time contains 
the value of whatever you have typed into it.  
That state, however, is inherent in the form 
element itself and React has no control over it.  
We can give control of the element 
to React by using React’s state. 
I’m going to return to ControlledForm.js, add 
a state property called name, and initialize  
it to an empty string. Then, I’ll add a value 
attribute to the name input and set it equal to  
this.state.name. What we’re saying here is 
that we want this particular input’s value  
to be the same as whatever the value of 
“name” is in the state of this component.   
This allows React to control the value of the input in 
its own state, and removes control from the DOM. 
If you save that, open the app in a new tab, 
and try to type something into the input, you’ll  
find that the input doesn’t work anymore. Can you 
think of why this might be, based on what you know  
about state in React? You might want to check the 
console to see if there are any errors or warnings  
that could be used as a hint. See if you can 
figure out why this input is no longer working,  
and spend a maximum of five minutes trying 
to fix it before going on to the next video.  
Don’t worry if you can’t figure it out as 
we’ll cover the solution in the next lesson. 
In this video, you’ve learned the difference 
between controlled and uncontrolled components,  
as they relate to forms in React. Uncontrolled 
forms have their inputs and functionality managed  
by the DOM, while controlled forms have their 
inputs and functionality managed by React.  
You learned the first part of how to give 
control of your form components to React  
by adding a property to the state and setting the 
value of the input equal to that state property.  
This causes a problem though, because 
now that React is controlling the form,  
the input doesn’t seem to work anymore.
In the next video, you’ll learn the solution  
to this problem and the rest of the steps needed 
to truly allow React to control this form.
------ 16Rz-9Pws6c ------
At the end of the last video, you had 
created a form in the file ControlledForm.js  
and had added a state property to the component’s 
state to allow React to control the name input.  
Unfortunately that broke the form, 
and the input no longer worked. 
In this video, you’ll learn why 
that happened and how to fix it. 
Let’s begin by opening this app in a new tab  
and looking at the console. You’ll 
see there’s a warning in it.
This message is telling us exactly what’s 
wrong. Since React is controlling the  
value of the field in its state now, we need 
some sort of functionality in the component  
to update React’s state whenever the form field 
changes. Luckily it’s pretty easy to do this. 
The first thing we need to do is listen to 
the onChange event of the form field, so that  
every time the field changes, we can execute 
some code. This is no different than setting  
an onClick handler for a button, which you’ve 
done several times now. On the input element,  
I’m going to add a new attribute, onChange, 
and set its value to this.handleNameChange.
You’ve probably guessed the next step by now. 
We need to actually define the handleNameChange  
method, just like we defined handleClick in 
earlier videos. The handleNameChange method will  
be called each time the form element changes, 
like when someone types something into it.  
Outside the render method, let’s create a new 
class property called handleNameChange and set  
it equal to an arrow function. This will be 
our event handler for the onChange event.
Now, a key thing to know here is that whenever you 
assign an event handler like this to the onChange  
event, the event itself will be implicitly 
passed into the handler as a parameter.  
So, our arrow function in this case 
will take a parameter called event.  
We can use this parameter to get the value 
of the field each time the event happens,  
so within the function I will set a variable 
called newValue equal to event.target.value.  
This variable will represent the value of the form 
field each time the onChange event is triggered.  
In fact, let’s log this variable to the console,  
save everything, then open the app in a 
new tab and take a look at the console.
If you type something into the text box while 
watching the console, you’ll see that even  
though the input is not changing, the characters 
you’re typing are being logged to the console.  
This should help you understand 
what’s really going on.  
It’s almost working. The field is in fact 
changing, but the React state, with its value  
of an empty string for the name property, 
keeps setting it back to an empty string.
Thus, we need to update the state when the 
onChange event is fired, so that each time  
a new character is typed into the field, it 
ends up in the name property in the state.
At this point there’s a good chance you know 
what you need to do to finally get this working,  
so I’ve got a small challenge for you: see 
if you can complete the handleNameChange  
method on your own so that it updates 
the state of the component appropriately.  
If you’re stuck, take a look back at 
some of the components we’ve built  
that have click handlers to handle button clicks, 
as the solution here will be nearly identical.  
In particular, you may want to look at the
StatefulGreeting.js. Pause the video here,  
take five minutes and see if you can work it 
out, then continue on to see the solution.
Welcome back! Were you able to get the 
form element working correctly? If not,  
here’s how I would do it: We definitely need the 
setState method, so I’ll call this.setState() and  
simply set the name property equal to our newValue 
variable from above. Now, whenever this event  
is called, it will update the state to reflect 
the new value of whatever’s in the form field.
I’ll save that, open the app and test it out. 
Everything is now working as expected. If you  
open the console you’ll see the value 
being logged is cumulative now, too,  
since each time a character is typed into the 
field, the name property in the state is updated  
to contain that new character, in addition 
to everything it already contains.
Let’s now go back and simplify the function a 
bit by removing the console log, removing the  
newValue variable and just setting the 
name directly from the event parameter.  
This does the exact same thing, 
it just looks a bit cleaner.
To summarize what’s happening here, 
when the component is initially loaded,  
the value of the form field is set to the name 
property from the state: an empty string.   
Each time a character is typed into the form field, the 
onChange event is fired. The onChange event is set  
to call this.handleNameChange, our event handler, 
which takes the event itself as a parameter and  
can be used to get the value of the field at any 
time. handleNameChange updates the state using  
the setState() method, giving the name property 
the value of whatever was typed into the field.  
The state update causes the component to 
rerender, and when it does, the new state is  
reflected in the form field thanks to the value 
attribute, which is set to this.state.name.   
All of this happens in less than a millisecond, which 
makes it completely transparent to the end user.
In this video, you’ve learned how 
to complete the creation of a form  
with controlled input elements in React. 
Any other inputs you add to the form  
can be controlled in the exact same way. All 
you need to do to create a controlled component  
is capture the onChange event from each 
form field you want React to control,  
and make sure that it has a matching property in 
the state so you can set its value accordingly.
Right now, the form fields in this form are 
controlled by React but the submission of the  
form is still handled by the DOM, which means 
when the user submits it, the page refreshes  
and the form data is lost. In the next video, 
we’ll add a couple more fields to this form  
and learn how to give React control 
over submitting the form as well.
------ mc8fY8kdzs4 ------
In the last video, we gave React control of the 
name field in the form we’ve been working on. 
In this video, we’re going to add 
a couple new fields to the form,  
give React control of them, and then learn 
how to handle submitting the form data  
so that the page doesn’t refresh 
when the submit button is clicked. 
Let’s begin by adding a couple of new fields to 
the form. We’ll assume that it’s a support form,  
so it’ll need a select box to select the category 
of your inquiry or the thing you need support on,  
as well as a text area to type in some 
comments or additional details about the query.
Let’s copy the label from the name input 
and change its htmlFor attribute to  
“id-category”, so it can be linked 
up with the category select box.  
Then I’ll create a new select element and give 
it an ID of “id-category” and a name of category. 
Inside the select element I’ll 
create three  elements,  
one for each category of question: “Website 
Issue”, “Order Issue”, and “General Inquiry”.  
Each of them has an abbreviated version 
for its value: website, order and general.
If you save that, you will see that the form 
is rendered as expected in the preview window,  
but it looks a little sloppy, so let’s wrap 
these fields in some divs so they line up nicely.
I’ll also add a heading at the top 
that says “Please fill out the form below”:
Last, I’ll add a new div below the category select 
box, and inside it create a label for the comments  
text area, along with a  element to 
hold the user’s comments. Note that in React,  
a textarea element is self closing, like 
an input, so it doesn’t need a closing tag.
Our form is looking good now, but of course these 
new fields are still not controlled by React.  
Before we continue onwards to submitting form 
data, I’d like you to try on your own to turn  
these fields into controlled components 
just like we did with the first text field.  
You’ll need to add a couple of new event 
handlers, some new attributes to the select  
element and textarea element, and some new 
properties in the state. Pause the video  
and take five minutes to try this on your own, 
then check back to see if you’ve got it right. 
Welcome back, to turn these 
into controlled components  
I need to complete three simple steps. First, 
I need to add two new properties to the state: 
category, which is set to website by default, 
and comments, which is set to an empty string.
Next, I need to add the value and onChange 
attributes to both the select element and the  
textarea element, giving the value attributes 
the appropriate values from the state,  
and the onChange attributes some 
appropriately named handlers to call.
Last, I need to write the onChange event handlers 
for each element. For these, I can just copy the  
handleNameChange handler twice and change the 
appropriate parts to match up with the new fields.
We could also use the computed property 
names javascript language feature  
you learned in javascript essentials to have 
one change handler for all input fields in our  
form. It is super useful, especially 
as the number of form fields grows.
Just remember the value of the html name 
attribute has to match the name of the key  
in the state we want to change. If it seems 
complicated at the moment, don’t worry,  
we’ll cover it in more detail later on.
With all that finished, I can 
save the file, run the app,  
and verify that the form works as expected. If 
you open the console and look at the component  
using the components tab in React Dev Tools, 
you can even see the state being updated as  
you change the form, which confirms React is 
now managing all these fields. At this point,  
make any needed adjustments in your code to ensure 
this is all working before you move forward.
For the final part of this video, I want to show 
you how to prevent the page from refreshing  
when the form is submitted. Luckily, this is 
really simple, and almost identical to what  
we’ve already done. If you’re guessing we might 
need an event handler, you’re right on the money.  
All the way at the top, on the opening form tag,  
I’m going to add an onSubmit attribute, 
and set it to call this.handleSubmit.
Now it’s as simple as writing 
the handleSubmit method.  
Just like the other handlers, it will be an arrow 
function that takes the event as a parameter.  
Inside it, the first thing I’m going to do is call 
event.preventDeafult();, which will prevent the  
default behavior of the form, which is to submit 
the data in a GET request and refresh the page.  
Below this, we can take any action we want. For 
demonstration purposes I’m just going to log a  
message to the console that contains the form 
data, which is now maintained in the state. 
When we save that and submit the form,  
the state is logged to the console, 
containing all the form data.  
From here, you would be able to use 
JavaScript to do anything you need,  
like submitting the data to an API where 
it could be used to update a database. 
Throughout the last three videos, you’ve 
learned how to work with controlled form  
components in React, including how to 
create different types of form elements,  
how to manage their values in the state, and how 
to handle this data when the form is submitted. 
Sometimes, working with controlled 
components can become tedious with  
all the event handlers and state properties 
needed to manage all the individual fields.  
In the next video, you’ll learn how to work with 
uncontrolled components in React by creating refs.
------ uWdmgfprErI ------
Over the last three videos, you learned the basics 
of creating forms with controlled inputs in React.  
These concepts are collectively 
referred to as controlled components.
In this video, we’ll take the same form 
we’ve been working with and convert it to an  
uncontrolled form, letting the DOM manage 
state changes to the input elements themselves,  
but still allowing React to have some 
control over the form’s behavior.  
You’ll also learn when it’s best to use 
controlled vs uncontrolled components.
For this video, you’ll need to know what 
refs are. A ref provides a way to access  
DOM nodes or React elements created in the 
render method. There are lots of uses for refs,  
but in this video we’re going to 
be focusing on only one of them.   
Using refs to allow React to reference the 
values of the various form elements in our form,  
without needing to handle them in React’s state. 
This will allow us to accomplish everything  
we’ve done so far without writing any event 
handlers or performing state updates in React.
To get started, I’ve already 
duplicated the ControlledForm component, 
renamed it to UncontrolledForm, 
and included it in app.js. You’ll need to  
pause the video now to complete this step. 
With the UncontrolledForm component created,  
it currently functions exactly the 
same as the controlled version.
We’re going to simplify our code quite a lot here. 
The first thing we can do is get rid of all these  
event handlers except for the submit handler. 
Because we won’t be using React state anymore,  
let’s delete that from the constructor, and also 
remove the references to it in the submit handler  
and in each of our form elements. While we’re 
at it, we can also remove the onChange and value  
attributes from these elements, since the DOM 
will be managing changes to these elements now.
If you save all that and run the app, the 
form should work, at least as far as being  
able to change the values of the fields. 
However, since the form is now uncontrolled,  
we don’t have any way to access the values of the 
form fields like we did before. With a controlled  
component, we were able to get the value of 
any of the input fields from the state, but  
without managing the fields in the state we need 
another way. This is where refs come into play. 
In the component’s constructor, I’m going 
to create a reference, or a ref to the  
first input element, the name text box, using 
the syntax this.inputName = React.createRef()
To tie it to the input element itself, 
I’ll add the ref attribute onto the input,  
setting it equal to this.inputName.
Now our class component has a reference to the 
name text box built right into the constructor.  
To access the value of the input in the submit 
handler, you can use this.inputName.current.value.  
I’ll log that to the console 
so you can see what I mean.
With this reference, React can access the value 
of the name input at any time, but the DOM can  
still manage its value, eliminating the need to 
write event handlers and deal with state updates.  
In fact, this ref just gives React access 
to the literal DOM element itself. If you  
log this.inputName.current to the console 
and submit the form, you’ll see it logs  
the input element itself. This is really useful 
because it proves you can actually use refs on  
any element throughout the DOM and access their 
individual attributes and properties as needed.  
Here, for example, we could access current.name,  
current.type or current.id among the many 
other built-in attributes an HTML element has.
With this knowledge, I’d like you to 
pause the video and take 3 minutes  
to create the refs for the other two 
input elements we’ve got in our form.  
When you’re done, unpause the 
video to see the solution.
Welcome back, this should have been pretty simple.  
To create the other refs, I first need to 
add them to the constructor. You can choose  
any names you want, of course, but I’m going 
to call mine inputCategory and inputComments,  
just so it’s obvious that they are references to 
inputs and specifically what they’re referencing. 
Then just like the name input, I just 
need to add the ref attribute to each  
of the others in order to link them 
together with their respective refs.
With that finished, I’ll add some 
logs to the handleSubmit method  
to verify we can access all the form values.
When I save everything, fill out 
the form and watch the console,  
all the form values are logged as expected. 
One last thing about using refs, when you want 
to give your form elements an initial value,  
for example, if we wanted to add 
“John Smith” to the name input  
here as a default value, you must use the
default value attribute.
This is because in React, using the value 
attribute like we did in the controlled component  
will override the value in the DOM, so the 
field won’t be editable. If you want to read  
more about how value and default value 
work in React, or about controlled and  
uncontrolled components in general, take a look 
at the linked React documentation on this page.
So, like functional and class-based components, 
there is always going to be some debate  
on when, where and why you should use 
controlled vs uncontrolled forms in React.  
And like the stateless vs 
stateful component debate,  
the answer to when you should use each depends 
greatly on your situation and preferences.  
For example, uncontrolled forms, while less 
featureful, are significantly easier to implement.
Controlled forms on the other hand, can 
do things like real time validation as you type,  
and conditionally enabling and disabling the 
submit button, since with a controlled component  
you have full control over its functionality right 
down to the onChange event for each input element.
In general, React documentation recommends that 
you use controlled components wherever you can  
even though they’re harder to implement, 
because in the end they are more useful and featureful. 
If you just need to throw 
together a quick and dirty form though,  
and don’t feel like worrying 
about state and event handlers,  
uncontrolled components will get the job 
done. There’s an excellent article linked  
on this page as well, which talks about some 
of the advantages and disadvantages of each.
In this video, you’ve learned how to 
convert a controlled form component into an  
uncontrolled one. You also learned what refs are,  
how to use them, and some of the advantages and 
disadvantages of each type of form in React.
This is the end of lesson three. In 
this lesson you’ve learned quite a lot,  
including how to work with lists, keys and indexes 
in React, how the component lifecycle works,  
and finally how to build React forms. In the 
next video, you’ll put your knowledge of these  
three domains to the test in another challenge 
before moving on to learn about React hooks.
------ jQcCWvZ54Mo ------
Throughout this lesson, you've 
learned about rendering lists,  
component lifecycle methods and forms in React.
In this video, you'll put your knowledge 
to the test with a mini challenge you'll be  
building a search bar component that filters 
names based on the value of the input field.
As you can see, the search results 
will be rendered dynamically below  
and additional information about the number 
of search results will also be displayed.
You are provided with one file names.js  
it exports an array of 100 strings each being 
a randomly generated first and last name.
Please don't worry if building a search 
bar component seems a bit daunting,  
I'll help you work through 
the challenge step by step.
Let's begin.
Your first task is to create the search 
bar component with some basic HTML,  
here are the steps we need to take:
First, create a stateful class component 
searchbar.js with an empty state for now. 
It will render a div inside which we'll need 
an h1 tag that says "Name Search" and a form  
underneath it, with a single text input field and 
a placeholder attribute that says "search names...". 
Below the form, we'll create a div 
that says we will render names here.
Once you've created the 
component, import it into app.js.
When you're done, the output will look like this:
Now pause the video and complete 
this part of the challenge.
Welcome back, hopefully you 
found this task pretty simple.
First, let's create the file searchbar.js 
and then use the rce code snippet to create  
our class component, and rconst 
to create a constructor inside it.
Then, inside the div we'll 
put an h1 that says namesearch  
a form of a single input of type text, and 
placeholder property set to search names.
Now, the only thing left to do is to create 
a div that says, we will render names here.  
I'll pass the div, the style prop equal to 
margin auto, just so it is always centered.
The last thing left to do is to 
import the component into app.js.
Make sure your code matches this and that you 
can see the following in the preview window,  
then move on to the next part.
For your second task, we'll render each element of  
the names array as a paragraph 
underneath the input field.
We'll also display the number of 
items in the component state array,  
to achieve this, we'll follow these steps:
First, import the names array 
from names.js as imported names.
Then, add the array to the state so that we 
can keep track of any changes we make to it.
Next, use the map function 
on the array and the state  
to return a paragraph for each name 
or it says we will render names here.
Finally, under the h1 put a paragraph 
that says matching name's found  
and displays the length of the names 
array in the state in curly braces.
As a side note, please check the console  
once you've finished and make 
sure no errors are showing up.
Your preview window should resemble this:
Alright, hello again, here's my solution.
First, I'll import the array from 
names.js and call it imported names.
Second, I'll initialize the names array 
in the state to the imported names.
Before I continue, let's just test that the 
imported names array is set in the state correctly  
by printing this.state.names, instead 
of the 'we will render names here' text.
Now that we know we can access our array, 
let's map over the values in this.state.names.
Now in the map function we will return 
a paragraph with the name variable.
Finally, under the h1 I'll place a 
paragraph that says matching names found.
Right after, I'll open a set of curly braces and 
display the value of this.state.names.length.
Now that everything is finished, let's check the  
preview window and the console to make 
sure everything is working as expected.
Uh-oh, red text in Chrome devtools 
is never a good sign, is it?
This is a good reminder to always make sure 
to check your console when you run your code,  
just in case there's an error.
But not to worry I'm pretty sure we've 
seen this one before, please pause the  
video now for a minute or two and try to 
make the error go away before we continue.
Ok welcome back, hopefully you were able to 
solve this as the solution is quite simple.
All we need to do is add a key prop 
to each paragraph and set it to name,  
as in this case all the names 
are unique for this array.
Well done, the error is now gone.
Once again, please make sure your code looks 
like this and your preview window matches mine.
Then, move on to the next task.
Now if you enter some text into the input,  
you'll notice that even though you're able 
to type words into it, nothing is happening.
Our next task is going to be to 
filter the imported names array  
based on the value of the input field 
and update the result in the state.
First, add an onchange attribute to the 
input field, inside write a callback  
function that accepts the event object and calls your handler function this.handlechange with it.
Then, create the handle change arrow 
function, inside call the toLowerCase  
method on the event object's text value, 
and save it to the input text variable.
We'll use this variable to save the value 
of the text we type in our search input.
Next, call the filter method on the important 
names array to leave out the names that don't  
match the input field's text value and 
assign it to filtered names variable.
Inside, call to lowercase on each 
name to make it case insensitive.
Now to compare a name with input text we'll 
have to use includes method, here's how it works. 
It returns true if a string can be 
found inside another one and false otherwise.
Finally, call this .setState with 
filtered names to update the state.  
Here's the end result we're trying to achieve.
This part may be new to you, so give 
yourself a maximum of 5 minutes to  
try to figure it out before playing the solution.
Welcome back, here's the solution.
First, let's make our input field listen to 
changes by adding the onChange attribute.
We'll pass it an arrow function that takes 
an event and calls our handler function  
this .handle change with it.
We haven't written the handle change function yet, 
so how about we do that now. Handle change will be  
an arrow function that takes an event, inside 
I'll create a const variable named input text,  
set it equal to event.target.value and 
chain on to lowercase function and call it.  
I'll also log input text to the console to 
make sure we wired everything correctly.
The next step is to filter out the 
names that don't match the input text.
I'll create yet another const variable, call it 
filtered names, and set equal to names.filter.
Inside, I'll call toLowerCase on each name 
to make it case insensitive, to check whether  
the input text can be found inside the 
name, we have to add includes(inputText).
This will return true if input text is a substring 
of name and it will return false, otherwise.
Finally, we can set the name state property 
to filtered names in the setstate method.
Now when we check the preview window, 
everything is working, well done!
There are no errors in the console  
and the names are filtered based 
on the value of the input field.
Throughout this lesson, we've covered a number 
of React topics: component lifecycle methods,  
how to render lists, and how to work with 
both controlled and uncontrolled forms.
In this challenge, we've put it all 
together by creating a search bar component,  
building generic and isolated components is 
the essence of creating React applications.
I've hope you've enjoyed this set of lessons 
and the challenge to bring them all together.
In the next set of videos, you'll learn 
about two most often used React hooks  
namely use state and use effect.
------ jdAuv9ynXew ------
Way back at the beginning of lesson 2, 
you were introduced to React components,  
including the two major types you’ve been working 
with so far, stateless functional components and  
stateful class components. In that introductory 
video, I also briefly mentioned React Hooks,  
and said that they could be used to add stateful 
functionality to stateless functional components. 
In this video we’ll provide a brief 
overview of the advantages of using hooks  
as well as explaining the basic functionality 
of the two most commonly used hooks in React.  
Then throughout the rest of this lesson, 
you’ll learn how to use these hooks in detail. 
React hooks are a relatively new feature of 
React, introduced in version 16.8, and they are  
basically little built in functions that allow you to use state and other features of React without writing a class.
As a quick preview, let’s take a look at the same workspace we used in that first video about components.  
In this workspace, there’s a file called HooksCounter.js.  
Take a minute to review the code 
before continuing with the video.  
Can you find the hook in the code? What 
happens when you click the button?  
Okay, welcome back.
Were you able to decipher what's going on?
This file defines a functional component 
called HooksCounter, but also utilizes the  
useState hook to define a state property called 
count, and a method to update it called setCount.  
The count is initialized to zero when we 
pass that initial value to the useState hook. 
When I click the button in the preview window 
where the app is running, the count is updated  
just like it would be in a stateful class 
component, but this component is a function.  
By using the useState hook, we can still make our 
component stateful, but we eliminate the need to  
define that state, define an event handler for the 
button click, give the component a constructor,  
or even define a class at all. Everything is 
taken care of with a simple functional component  
and the use of the useState hook. You’ll learn 
exactly how this hook works in the next video,  
but for now let’s talk a little 
bit more about hooks in general. 
Hooks are completely opt-in, and backwards 
compatible. They won’t break anything in your  
React applications, so you can use classes 
and hooks in the same app interchangeably.  
This is common when converting an older 
app from using classes to using hooks.  
The React team states that they have no plans to 
eliminate classes from React, so you can still  
use them, and convert your apps to use hooks 
gradually over time, component by component. 
React hooks also greatly simplify your React 
code. With hooks, you can use all the powerful  
features of stateful class components like state, 
event handlers and component lifecycle methods,  
without having to actually use a class! That 
means all those complex component lifecycles,  
event handlers, and probably most importantly, 
the “this” keyword, will be all but eliminated  
from your React vocabulary by using Hooks.
The two hooks we’ll be looking at over the next  
few videos are the useState hook and the useEffect 
hook. The useState hook, as you already know,  
is used to add state to a functional component, 
so it effectively replaces the requirements for  
defining a state in your components with something 
simpler. The useEffect hook, on the other hand,  
can be used to effectively replace all those 
component lifecycle methods we learned about,  
like componentDidMount, componentDidUpdate, 
and componentWillUnmount. 
Now, you might be wondering why we spent 
all this time going over class components,  
component lifecycle methods and state if 
we’re now about to replace it all with hooks.  
The truth is, you could have just learned hooks 
right off the bat, but without understanding the  
advantages they provide and the complexity they’re 
replacing, it would have been really difficult to  
conceptualize what state and component lifecycles 
are, or why we even need them. Additionally, since  
hooks are still relatively new, it’s very likely 
that you’ll run into class components in React  
code in the wild, so it would be a real tragedy if 
you had left this course having never seen them. 
So, in this video you’ve learned about the 
usefulness of React hooks and learned the  
purpose of the two hooks we’ll be focusing on 
for the next few videos: useState and useEffect. 
In the next video, we’ll get started by building 
our first component using the useState hook.
------ trwA8veUxH8 ------
In the last video, we introduced 
React hooks and talked about the  
two hooks we’re going to focus on for the 
next few videos: useState and useEffect.
We’ll get started with the useState hook 
in this video. To keep things interesting,  
rather than just rebuilding the HooksCounter 
component we looked at in the last video,  
I’m going to show you how to use hooks 
to convert the stateful controlled form  
component we made at the end of lesson three 
into a functional component that uses hooks.
The useState hook, as you should know by now, can 
be used to give state to a functional component.  
For our purposes in this video, it will allow 
us to rewrite the ControlledForm component  
as a functional component and 
greatly simplify the code,  
while still allowing React to fully manage the 
form on its own, with no help from the DOM.
To get started, let’s create a new file called 
ControlledFormHooks.js and inside it, use the  
snippet rfce to create and export a new functional 
component that just returns “it works!”.
Then I’ll import and include the new component in 
App.js and run the app to make sure it’s working.
Now I’m going to copy the entire form from 
ControlledForm.js so we can start working on it.  
I’ll replace everything in the return statement 
of ControlledFormHooks.js with that form.
This won’t work yet, since in a functional 
component we have no use for the this keyword,  
but let’s think about exactly what 
needs to happen in our component’s state,  
so we know what we need to 
do with the useState hook.
Looking at ControlledForm.js, we have three things 
that need to be managed in the state, the values  
of the name, category and comments input fields. 
For that to happen, in this class component we had  
to both define them in the state and also define 
event handlers for them such as handleNameChange,  
handleCategoryChange and handleCommentsChange. 
With the useState hook this is a lot simpler.
Returning to ControlledFormHooks.js, the first 
thing I’m going to do is import { useState } in  
curly braces from React. Don’t worry about 
why we need the curly braces much for now,  
but if you’re curious it’s because useState is 
a named export and not a default export. 
With that done, we’re ready to use the 
useState hook. Let’s take the first input,  
name, as an example. To match the 
functionality of the class component,  
we need both a state property called name 
and a method to update it. To do that,  
we can use destructuring to define name and 
setName and set them equal to useState(),  
passing it the initial value of 
name which will be an empty string.
The useState hook takes the initial value of 
the desired state property as a parameter,  
in this case an empty string, and like magic, 
returns the state property with its initial value set,
and a method to update it! You can call these 
properties anything you want, but the convention  
is to set your property name to whatever you want 
to call it in the state, and then call its updater  
“set” followed by whatever the property name is. 
Since we also need state properties for category  
and comments, you can use the useState hook in the 
exact same way. You should be able to tackle this  
on your own with no problem, so pause the video 
for a minute or two and use the useState hook  
to set these other two properties, 
giving them the correct initial values.
Welcome back! Hopefully you came up with 
this for the other two input fields.  
All I’ve done is copied the same syntax down 
and changed the names of the variables so they  
match up with the fields. I’ve given them the same 
initial values as the ones in the other component.
Just like that, our form now has three state 
properties and three methods to update them!  
Now let’s go through the form and simplify the 
existing fields by allowing them to use these  
properties and setters we’ve created. For 
the name field, for example, I can change  
the value attribute from this.state.name to 
just name, since that variable was returned  
back to us by the useState hook. I can also 
replace the onChange handler with the new one,  
setName, by passing it as an arrow function 
that takes the event as a parameter.
The function then returns a call to 
setName, passing it event.target.value,  
which will be used to update the name 
variable. So, whatever you want the new  
value to be, you just pass it into the setter 
function you created with the useState hook.
The other two fields are exactly the same except 
for the names of the properties and the methods  
to update them, so pause the video now and take 
2 minutes to update those to match this format. 
As you can see, all I’ve done 
is copied the exact same syntax  
and changed the properties that are being updated.
The last part is to remove the reference to 
this in the onSubmit attribute of the form.  
For this one, we still need to define a 
submit handler since it’s not part of the state.
Up here under the hooks I’ll create a new constant  
called handleSubmit, which will be an arrow 
function taking the event as a parameter just  
like in the other component. It will first call 
event.preventDefault(); to prevent the default  
form action, and then we’ll log name, category and 
comments to the console to confirm it’s working.
Now all I need to do is remove this from the 
onSubmit attribute and everything should work  
exactly the same as the other form. Let’s test 
it out. I’ll save everything, run the app,  
and open it in a new tab. If I open the inspector 
and inspect the component using React Dev Tools,  
I can see the state being updated as I change the 
form, so it looks like the hooks are all working  
as expected. If I look at the console and submit 
the form, I see the form data logged successfully.
In this video, you’ve learned both how 
to implement and use the useState hook,  
as well as how to convert a 
class component that has a state  
to a functional component that uses hooks to 
do the same thing. We did it in three steps:
First, we defined the state properties we needed  
and their setters and initial 
values, using the useState hook.
Next, we updated the onChange and 
value attributes of each field  
to use the new properties and setters.
And finally, we recreated the submit handler so 
we could eliminate the use of the this keyword  
in the onSubmit attribute of the form.
This process is a useful skill to have,  
since you may find yourself in the future 
converting old stateful class components  
to functional components using hooks in apps 
that were created before hooks were around.
In the next video, we’ll look at how to use  
the useState hook to work with 
more complex state properties,  
like arrays and objects, as well as how to use it 
to update state based on previous state values.
------ -CaxW5oPCJA ------
In the previous video, you learned 
the basics of using the useState hook  
by converting the controlled form we’ve been 
working on to a functional component using hooks.
In this video, let’s talk about 
another use case for useState.
Using it to update a state 
property that is an array.
I’m going to create a new file for this one,  
called UseStateWithArrays.js, and inside 
it I’ll use the rfce snippet to create  
a new functional component. Inside it let’s just 
render “it works!” and then include it in app.js.
With that working, let’s import useState at the 
top and create a new state property called nums  
with an initial value of an 
array containing the numbers  
1, 2 and 3. It will have a 
setter function called setNums.
Moving into the body of the component, 
I’m going to create an unordered list,  
then use nums.map to iterate over the numbers 
and return a list element for each one.  
For simplicity I’m just going to use the 
number itself as the key for each list item.
Finally, just above the unordered list I’ll add 
a button to add a new number to the array in the state.
The goal is to keep adding numbers 
to the list each time the button is clicked.  
Let’s run that and see how it looks.
So we’ve got our component rendering 
properly and a button to add a new  
item to the array in the state. Now I’ll give 
the button an onClick attribute of addNums,  
which is a function we’ll want 
to call each time it’s clicked. 
To define this method, just under the useState 
hook I’ll create a new const called addNums  
and set it equal to an arrow function.  
It’s going to return a call to setNums, our 
setter function from the line just above,  
and we’re going to pass in the new array we want 
to use, which will only contain number 4 for now. 
You might already see a problem with 
this. Let’s run it and see what happens.
As you can see, when I initially 
start the app I’ve got the numbers 1,  
2 and 3 rendered in the preview window. When I 
click the button though, the original array is  
replaced with the new one, which contains 
the number 4. To solve this problem,  
we need to return to the spread operator and 
spread the values of the current nums array  
into the one we want to put in the 
state, and then add the number 4.
Now, each time we click the button, the array in 
the state is updated to contain all the previous  
values thanks to the spread operator, plus the new 
value, which is 4. To make sure we don’t always  
add number 4, we will replace it with nums.length 
+ 1 so that the numbers increase by one.
Let’s run it one last time to 
check everything is okay,
and it is! Well done! 
Everything’s working perfectly.
But before we finish this video, you may 
be wondering why we didn’t just use some  
array methods, such as push or pop, 
which you’re already familiar with.  
There's a really important reason why you 
shouldn't do that, which I'll demonstrate  
by creating a buggy version of the 
‘addNum’ function we’ve just written.
Let’s call it buggyPushNum. It will 
push nums.length + 1 to the nums array,  
call setNums with it and then log 
the nums array to the console. 
I’ll also add a button for it 
that says “Buggy Push Item”.
As I click it, you can see, the nums array 
is being updated, but there’s no re-render!
React hasn’t detected any 
changes as the nums array  
is still referencing the same place in memory.
Now, if we click the ‘add item’ button that 
makes use of the spread operator, React detects  
the change and we can see a sudden “jump” and 
the newest item added at the end of the list.
Updating the state like this 
can lead to unexpected bugs.  
Instead, we try to handle the state 
using functions like map and filter.
Finally, you may be wondering how 
we would implement a remove last  
number functionality. You’re 
welcome to try on your own,  
just let me give you a hint that it would 
probably be best if you used the filter method.
Please pause the video now and come 
back in a few minutes to check the solution. 
Ok, welcome back, here’s how I did it.
First, I wrote a removeNum handler.  
In the callback function, I made sure to return 
false when dealing with the last item.   
Whenever the filter method returns false for an item, 
that item is left out of the resulting array.  
Finally, that’s what we’re setting the 
nums array to with the setNums function.
The last thing to do was to add a “Remove 
Item” button with an onClick attribute  
that points to the removeNum handler. 
In this video, you’ve learned three key points 
about using the useState hook with arrays:
First, the array we pass as an argument to 
the setter function, always overwrites the old one.
If you want to add a value to the array, 
spread the existing array into the one you’re  
pushing into the state with the new value. If you 
want to remove items, use the filter function.
Second, never update the state directly or 
use impure functions like push() or pop().  
Doing so could lead to bugs and no re-renders.  
Rather, use pure functions like map, 
filter, reduce or spread operator  
that return a copy of an existing array and 
therefore are a safe way of updating the state.
Third, you saw the correct 
way of adding and removing  
elements from an array using pure functions. 
In the next video, we’ll dive into two other 
possible ways you can use the useState hook: 
Updating objects in the state 
and updating state based on previous state.
------ u_T_HOkHyaY ------
In the previous video, you learned how to use 
the useState hook when working with arrays.
In this video, let’s dive into two other 
possible ways you can use the useState hook: 
Updating objects in the state, 
updating state based on previous state.
Let’s begin with how to update objects 
in the state using the useState hook.  
This is nearly identical to the process for 
updating arrays. For this last part, I’ve  
provided the code on this page for you, so pause 
the video here and copy it into a new file called  
UseStateWithObjects.js, import and include it 
in App.js, and then we’ll go through the code.
This component is pretty simple: it first 
sets a name property and a setName setter  
using the useState hook. The initial value 
of the name property though, this time,  
is an object containing a first name and a 
last name, both initialized to an empty string.  
In the component body I’ve created a form which 
contains two input fields, one for first name  
and one for last name, and at the bottom, I’ve 
rendered a JSON version of the name property  
just so we can see it in the preview window. 
Let’s run the app and see it in action. 
If you type your first name into the first text 
box in the preview window. You’ll see the state  
is updated, but there’s a problem. The object is 
completely replaced, and the lastName property  
is removed. If you then move to the lastName box, 
even though the firstName box maintains its value,  
as soon as you start typing into the lastName box, 
the firstName property is removed from the state.  
Thus, there is a disconnect between what’s 
actually in the form, and what’s in the state.
Knowing what you know about how to update 
arrays using the useState hook. Pause the video  
here and take 2 or 3 minutes to see if you can 
figure out how to adjust the onChange event for  
each form field so that the state is maintained 
appropriately when you update either text box.
Welcome back. If you figured out that 
we need the spread operator again,  
you’re right. To fix this, all we need 
to do is spread the current value of the  
name property into the object we’re pushing 
into the state with the setName function.
By doing this, the entire name object 
will be copied into the new object,  
and the appropriate properties will 
just be replaced with their new values.
Finally, we come to the last part of this video,  
which is how to update the state based on 
the previous state using the useState hook.  
You’ve actually already seen how to do 
this using classes in two earlier videos,  
so this will just be a quick review of 
this code, which you’ve already seen.
Let’s take a look back at the 
StatefulGreetingWithPrevState Class  
component you made when learning 
about state. In that component,  
you might recall that we attempted to implement 
an “incrementFive” method, but it initially  
didn’t increment properly because we needed 
to use the 2nd form of the setState method(),  
which takes a function as its parameter. 
In that video, we passed in the previous  
state of the component as a parameter, and 
updated the count based on the previous state.  
If this isn’t familiar to you, I’ve linked 
that video on this page so you can go and review it.
The useState hook works almost identically when 
updating the state based on the previous state.  
To see that in action, let’s take 
a look at the react components repo  
from when you were first introduced to React 
components and take a look at HooksCounter.js.
Again, here we are passing to the setter 
function useState hook an arrow function  
that takes the previous value of the state 
property, and that function returns count + 1.  
So, remember that when updating the state based 
on the previous state using the useState hook,  
rather than just passing the setter function 
the new value to go in the state,  
instead you should pass it an arrow function 
that takes the previous value as a parameter  
and returns the new value based on the previous.
In this video, you’ve learned two key 
points about using the useState hook.
First, when working with objects, always spread 
the object you’re replacing into the new one,  
just like with an array, as without doing 
this, the entire object will be replaced.  
Then follow it with the 
properties you’d like to change.
And second, always pass it a function whenever 
the value you’re pushing into the state depends  
on something in the previous state, just 
like you would with the setState method. 
In the next video, you’ll start learning 
how to replicate component lifecycle  
behavior in functional components 
by utilizing the useEffect hook.
------ EnBg1AFs_6M ------
In the last video, we looked at some 
different use cases for the useState hook,  
which can replicate the functionality 
of state in functional components. 
In this video, we’ll explore a new hook, 
called useEffect, which can be used to  
replicate the functionality of the component 
lifecycle methods you learned about earlier,  
again without needing to write a complicated 
class component. By utilizing both useState and  
useEffect, you can successfully perform all the 
primary functions of a stateful class component,  
without ever having to write a class.
Side effects, as they relate to React components,  
refer to anything in a React component that 
affects something outside the component itself.  
For example, fetching data from an API, 
creating and destroying event listeners,  
and updating an unrelated part of the 
DOM would all be considered side effects.
In class components, you had to make use of 
lifecycle methods such as componentDidMount,  
componentDidUpdate, and componentWillUnmount 
to perform these so-called “side effects”.  
In functional components using hooks, 
you can perform these same side effects,  
and replicate the functionality of 
all three of these lifecycle methods,  
using a single function: the useEffect 
hook. Let’s take a look at how it works.
I’ve created an example component here called 
ClassCounter.js to refresh your memory on how  
component lifecycle methods work. Don’t worry 
about copying this, just follow along for now.  
In this component, I’ve given it a state 
property of count and initialized it to zero.
In the render method I’ve created an 
increment button that renders the current count.
This button has an onClick handler 
that returns a call to this.setState,  
which uses the familiar arrow function form of 
setState using previous state to update the count.  
When I click the button, the count is updated.  
Now, consider that you want to perform a side 
effect when you update the count, such as updating  
the title of the document to match the count. 
The document title is not part of the component,  
so this change to the title would be considered a 
side effect of the component mounting or updating.  
Let’s assume you want to do this both when 
the component first mounts, and every time  
it’s updated, so that the title of the document 
always stays in sync with the current count.
For this functionality, I’ve 
implemented two lifecycle methods:  
componentDidMount to handle setting the document title as soon as the component is mounted,  
and componentDidUpdate to handle updating it 
every time the component is updated.   
If we open the app in a new tab and click the button, everything is working fine: both the button text  
and the document title are incrementing just like 
they should. The problem with this is that it’s  
verbose and complex. We can make it a lot simpler 
using the useState and useEffect hooks. Now that  
you’ve seen the functionality we’re trying to 
replicate, it’s time to start writing some code.
I’ll create a new file called UseEffectCounter.js  
and inside it I’ll create a new functional 
component using the rfce snippet. Then, I’ll  
import and include the component in App.js as 
usual. Like the class component we just looked at,  
we need a state property called count, and 
to give our functional component a state  
we’ll need to use the useState hook. So, let’s 
first import the useState hook at the top,  
and then create the count and setCount variables 
using it, while initializing the count to zero.  
I’ll also recreate the button from the previous 
component, giving it an onClick attribute that  
calls the setCount method and increments the 
count by one based on the previous count.  
We’ve covered this previously, so if you’re 
struggling here, I would recommend that  
you go back and make sure you understand 
the useState material before continuing.
With this done, the functionality almost 
matches what the class component does,  
except for updating the document title. Remember, in the class component we  
updated the document title when the component 
mounts using the componentDidMount method,  
and updated it using the componentDidUpdate 
method. With functional components,  
we can use the useEffect hook. Again, let’s 
import that hook at the top next to useState.
After all this explanation, it’s 
actually very simple to use.  
Underneath the useState hook, 
I’m going to call useEffect.
The useEffect hook takes, as a parameter, 
a function that will be executed after  
every render of the component. In this way, it 
will take care of running whatever function you  
give it both immediately after the component 
mounts, and every time it updates. In our case,  
all we want to do is update the 
document title to reflect the new count  
every time it’s incremented, so let’s pass 
useEffect an arrow function that does this.
That’s all it takes. Now, if you run the 
app and open it in a new tab so you can  
see the document title, you’ll see we’ve got the 
exact same functionality as the class component,  
with a lot less code. Of course I understand this 
was a really long-winded way of showing you how  
to use this hook when it’s so simple, but I wanted 
you to understand exactly which functionality it’s  
replacing in class based components. The key 
thing I want you to remember from this video  
is that useEffect runs the function 
you give it after every render,  
no matter what. This will become a key 
point to remember in the next few videos.
In this video you’ve learned the simplest 
implementation of the useEffect hook.  
We first explored a class based component that 
used lifecycle methods to execute some code  
after every render, and then you learned how to 
replicate that same functionality more elegantly  
by using the useEffect hook. As some of you 
may already be realizing, there are going to be  
many situations where executing a function after 
every single render is not exactly what you want. 
For these situations there are a few 
other ways you can use the useEffect hook,  
and you’ll learn about the first 
of those in the next video.
------ lj2jMmgBRrE ------
In the last video, you learned how you can 
utilize the useEffect hook to replicate the  
functionality of both componentDidMount and 
componentDidUpdate with a single function. 
In this video, we look at how to streamline 
this process by learning how to cause useEffect  
to run only when specific properties are updated.
The reasons you might want to do this are many,  
but the most obvious one is that it’s inefficient 
and almost certainly unnecessary to run every  
effect after every single render in a component. 
In the component we built in the last video,  
the only thing that should really affect whether 
the document title or the text of the button  
should change is whether the component’s count 
property has changed. If there were other state  
properties in this component, the effect we 
wrote in the last video would run every time  
any of those state properties changed, since, 
by default, useEffect runs after every render. 
Now, it’s perfectly valid to have 
multiple useEffects in a single component.  
For instance, we might hypothetically have a timer 
on this component also, updating it every second,  
and each update would thus cause the component 
to rerender. In our current implementation,  
the document title would also be updated 
every single time the component rerenders,  
even though the count property, which would be 
completely unrelated to our hypothetical timer,  
is not changing. Ideally, each effect would only 
run when it actually needs to, not every single  
time the component renders. In this case, since 
the document title and the text on the button  
should only change when the count changes, the 
effect too should only run when the count changes. 
Luckily, it takes only a very tiny change to our 
existing code to make this work. In our useEffect  
function, all we need to do is specify a second 
argument: an array containing all the properties  
that this effect should be watching for changes. 
In this case, there is only one property this  
effect should care about, and that is the count 
property. So here, after the first argument,  
our function which is going to update the 
title, I will specify an array containing count.
This tells the useEffect hook that this function 
should only run when count changes. To confirm  
it’s working, I’m going to add a console log 
here to show when this effect is running. 
Now, I'll copy the whole property and effect
 and create a new one for a new property called count2.
Also, I'll duplicate the button 
and update it to work with the count2 property.
With this saved, let’s open the console 
and run the app. Don’t worry about what the  
document title is for now, what I want you to 
recognize is what’s showing up in the console.  
When I click the button to increment the original 
count, only the original count’s effect runs.   
The same is true for when I click the new button. 
In the console you can see that only count2’s  
effect runs. If I remove the array from count2’s 
effect, then click to increment the first count,  
both effects run. Vice versa, if I remove the 
array from the first effect, this effect will now  
run on every rerender, so when I click the button 
to update the second count, the first effect runs  
even though the first count hasn’t changed. 
This is the behavior we’re trying to avoid. 
When you have multiple effects in a single 
component, you don’t want every single effect  
running every time the component renders. 
What I want you to 
take away from this video
is that when you use the useEffect hook, you 
should nearly always specify the second parameter  
and provide the list of state properties 
the effect should be watching for changes.  
In the array, you can specify props, 
state properties, or a mixture of both,  
and you can specify multiple properties if 
the effect depends on more than one thing.  
The key thing to remember though is that if you 
don’t specify this parameter, your effect will  
run on every single render, which will become 
a major performance problem in larger apps. 
In this video, you’ve learned how to restrict 
your effects to run only in specific instances.  
You should always specify explicitly 
which state properties and props  
your effect depends on so that 
it only runs when it’s needed. 
In the next video, we look at how to 
duplicate the functionality of componentDidMount  
more effectively, like when you want to run an 
effect exactly once when the component mounts.
------ ooHnh8RFLw4 ------
In the previous video, you learned how to run your 
effects only when one or more specific properties change.
In that video, we restricted the effect 
related to the count property such that it only  
runs when the count property changes.
Sometimes, though, you might want to run  
an effect only one time, like when the 
component mounts, and then never again  
unless the component is remounted. Let’s 
learn how to do that in this video.
To do this, you might just think you can leave 
the second parameter to useEffect out. If we  
pass it no array, that means the effect depends on 
nothing, right? If you’ve been following along for  
the last couple videos, hopefully you realize how 
wrong that is. If we pass no array to useEffect,  
it actually means that the effect depends on 
everything! It will run any time the component  
is rendered, no matter what has changed.
Knowing that, you might be able to figure  
out at this point what we need to do in order 
to restrict the effect to only run once.  
As we write this next bit of code, I want 
you to keep this in the back of your mind.
Inside UseEffectCounter.js, let’s add 
another state property called time  
by using the useState method. I will call its 
setter setTime, and initialize it to 0.
Let’s also render it in a  
element beneath the button.
If you save that and run the code you’ll see 
the time showing up just beneath the counter. 
Returning to the question of how to run an effect 
only once, let’s assume that when this component  
mounts, I want to create an interval that will 
update this time variable once per second.  
For this, we need an effect, so under the first 
effect, I’ll make another call to useEffect and  
pass it an arrow function. This isn’t going 
to make sense right now, but bear with me here,
because there’s a good reason we’re doing 
this. Let’s say for argument’s sake that this  
effect also depends on the count. So first, in the 
function I’ll log “creating timer” to the console,  
and give it a second parameter 
of an array containing count.
To be clear, this is the count that will 
be updated when the button is clicked,  
but the effect we’re creating will 
be related to the time property. 
Next, I will create the interval 
to update the time every second. 
Remember that the setInterval 
function takes two parameters,  
the function you want to run, and 
how long the interval should be.  
For us, we’ll want to run setTime every 
1000 milliseconds, or once per second.
The last step is to tell setTime what we want 
the new time to be, and this is all stuff you’ve  
already seen. Let’s set it to a function that 
takes the current time and returns time + 1. 
If you save all that, and run the app, you’ll 
see that the interval is working as expected,  
updating time by one every second. 
If you open the console 
and refresh the preview window,  
you’ll indeed see that the effect is 
run when the component is mounted.  
As you might expect though, watch what happens 
when I click the Increment Count button.  
Something is definitely wrong here. In the 
console, since we passed this second effect  
an array containing count as well, every time we 
click the count button a new interval is created.  
The reason for the strange looking updates to the 
time is that there are multiple intervals running,  
and each one is trying to update 
the time by one, once per second. 
Obviously we don’t want this effect connected to 
the count, but if we remove the array completely,  
then the effect will run every time the component 
renders, including when the time is updated,  
which means every time the time is updated, 
another interval will be created which is  
also updating the time, and the effect will 
compound exponentially eventually resulting  
in a browser crash or possibly even hanging 
your computer to the point you need to reboot.  
If you don’t believe me and 
you like to live dangerously,  
save any work you’ve got open on your computer 
and try removing the array and running the app. 
How then can we tell this effect that we only 
want it to run one time, when the component is  
first mounted? If you guessed that we need to 
pass the second parameter as an empty array,  
you’re absolutely right. Any time you 
only want the effect to run one time,  
you must pass the useEffect hook an 
empty array as the second parameter:
Now, when I run the app, the timer still works and 
incrementing the count doesn’t affect it at all.
So far, you’ve learned how to use the useEffect 
hook to run a side effect on every single render  
by supplying no second parameter, how to run an 
effect conditionally by supplying the specific  
properties it should be watching for changes. And 
in this video, how to run an effect only once by  
supplying an empty array as the second parameter.
In the next video, you’ll learn how to use  
useEffect hook to run a cleanup function, mimicking 
the functionality of componentWillUnmount.
------ 7kpZ-PPx1bA ------
In the previous video, you learned how to run 
effects only one time by passing the useEffect  
hook an empty array as its second parameter. 
This allows you to effectively replicate the  
functionality of the componentDidMount 
lifecycle method from class components.
In this video, you’ll learn how to 
mimic the componentWillUnmount method,  
which is primarily used for running 
cleanup functions, such as removing event  
listeners and stopping timers and intervals.
A cleanup function then, is any function that  
should be executed just before the component 
unmounts, in order to “clean things up”, so the  
browser is not left with unused event listeners, 
timers, hung network requests and so on. 
Before showing you how to create a 
cleanup function with the useEffect hook,  
I want to show you why we need them. You saw 
this in earlier videos, where you created a mouse  
tracker component and then had to clean up the 
event listener to prevent errors in the console  
but I want to give you another example here.
I’m going to create a new file 
called UseEffectCounterContainer.js,  
and inside it create a new functional 
component using the rfce snippet.  
This component will have only one state property 
and be quite simple. I’ll import useState at the  
top so we can give our component some state, and 
then give it a state property called display,  
with a setter called setDisplay. The 
display will be set to true initially.
In the main div I want to render the 
UseEffectCounter component we’ve already  
built if display is True, and hide it if display 
is False. Let’s open a set of curly braces and use  
the short circuit syntax to render the component 
if display is true or don’t render otherwise.
Of course we’ll also need to 
import UseEffectCounter at the top. 
And the last thing we need a button to toggle the display on and off. 
So I’ll create a new button 
with the text Toggle Display, then give it an  
onClick handler which will run an arrow function 
returning a call to setDisplay. To the setter,  
we will pass in not display, so whatever display 
is currently, this will set it to the opposite.
With that saved I’m going to head over to 
App.js and replace the UseEffectCounter  
component with the UseEffectCounterContainer 
component, and update the import at the top.  
Now I can toggle the display of 
the counter component on and off.
Now let’s go back to UseEffectCounter.js and 
make a small change to our useEffect that  
creates the timer. All I really want to do here 
is add a console log to show you what’s going on.
So, I’ll just add one that says 
 "interval is executed".
Ok, if you’re wondering why we went to all 
that trouble, don’t worry - we’re about to  
get to the good part! Let’s open the app 
in a new tab and check out the console.  
I’m going to refresh the page and clear out 
the console just so everything is easy to read.  
So, when I first load the page, we see all three 
things happening in the console. First, the first  
effect we created is run which handles updating 
the count attached to the button and the document title,
then the timer is created. And finally, we 
see the interval being executed once per second. 
Now here is the key thing I want 
you to understand from this video:  
watch what happens when I toggle the display.
The timer is gone, the component has been 
unmounted, but the interval is still there ticking away.
Just like the mouse tracker component that 
attempted to update an unmounted component when  
we moved the mouse, this interval is now trying to 
update the unmounted UseEffectCounter component.  
This is the key reason we need to run a cleanup 
function to clear the interval. If I toggle the  
display a few times, you’ll see that the rate 
at which the interval is being executed keeps  
increasing, because each time I toggle the 
display on, it creates a new interval as the  
component mounts, but when I toggle the display 
off, that interval is left behind, still running. 
Luckily, like the rest of the 
functionality of useEffect,  
it’s really simple to fix this. All we need 
to do is return a cleanup function from the  
function we pass to useEffect. In our case, 
when the component unmounts we need to call  
clearInterval, so here in the function we’re 
passing into useeffect, let’s just return a  
function that calls clearInterval() on 
the interval const we created above.
I’ll also log “cleaning up” to the console. 
Let’s run the app again and check the console. 
Now, when we first refresh the page, we see the 
same as before. First the first useEffect we made,  
then the timer is created and the interval 
starts ticking. When I click toggle display,  
the cleanup function is run, clearing the 
interval, and the component is unmounted.  
When I toggle the display back on, 
the whole process happens again. 
So in this video, you’ve learned 
how to mimic componentWillUnmount  
by executing a cleanup function 
using the useEffect hook.
Let’s review the key parts of 
this effect.
First, we have the two parameters to 
useEffect, the function we’re going  
to execute, and the empty array so it only 
executes once when the component mounts.
Next, inside that function we do three things, log 
“Creating Timer” to the console, then create the  
interval, and then return the cleanup function. 
The update to the time actually happens inside the  
interval, where we define both the function 
to run, ultimately the setTime function,  
and the interval we want to run it at, every 1,000 
milliseconds. In the cleanup function, we just  
clear the interval by passing the clearInterval 
function the interval we wish to clear.
I realize there is a lot going on here. 
There are a lot of arrow functions and  
functions returning other functions, which 
can be quite confusing. Take the time to  
study this and understand how it works, but 
don’t worry if you don’t get every single  
detail right away. As you use these hooks 
more and more, it will become clear to you.
This is the last video in the hooks 
series and the final video of lesson 4.  
In the next video, you’ll put it all together with 
a small challenge and then move on to lesson 5,  
where you’ll learn about working with HTTP, 
and sending and retrieving data in React.
------ z7IHBiS42e8 ------
So far in this series, you have learned quite a 
lot about React. In lesson one, you learned about  
React fundamentals and the basics of how React 
works, as well as its file and folder structure.  
In lesson two, you learned all about props, 
state and different kinds of React components.  
As well as event binding and how to handle 
different types of component updates.
Then, in lesson 3, you looked at how 
to render more advanced components  
that included lists, tables, and forms. As well 
as learning about the component life cycle.  
Finally, in lesson 4, you learned all about React 
hooks and how you can use them to simplify your  
code and eliminate the need for class-based 
components.
One thing we have not talked about yet, which
might seem strange for a course encompassing 
building web applications, 
is HTTP and working with data in React.
In this video, I'll introduce these 
concepts and how they relate to React and then, 
over the next few videos you'll see how react can 
use them to fit into a larger web architecture.  
Before we get too deep into the weeds 
of working with HTTP and data in React, 
you should remember one key thing: React is 
just a front-end library. Technically, a React  
application can happily survive without ever 
knowing that HTTP even exists. React components  
simply use JavaScript to take in props and state 
and return the various parts of a user interface. 
They never need to reach out to a web server at all. 
With that in mind, in reality it is almost  
unheard of to see a React application that doesn't 
have some sort of interaction with a web server. 
Most commonly this interaction involves fetching 
data from a server and putting it into props or  
state so it can be used in the user interface.  
React components also commonly send the data to  
web servers, which then process the data and send 
back a response containing a result, like a success  
or error message, or some result data that might 
then be utilized in the component's props or state. 
The simple point to take away here is that 
in order to get your React application to  
interact with a larger web architecture, like 
one including a web server or a database.  
All you really should be asking yourself 
is, what do I need from the back end?  
And how can I get it into my component's props 
or state? React is agnostic with regard to how  
you handle HTTP requests and responses. You can use 
the browser's built-in fetch API, jQuery, raw AJAX requests,  
or a dedicated HTTP library like Axios. 
React doesn't care how you make HTTP requests  
or if you even make them at all, all it cares about, 
is what it has to render from props and state.  
To demonstrate, I've created a demo component 
here in HTTPRequests.js. This is a standard posts  
component you'd see all over social media websites, 
which we'll build in the next video. Don't worry  
about understanding all of this right now, I just 
want to show you how it works and then we'll build  
it from scratch. The post component uses the Axios 
npm package to make requests to JSONPlaceholder,
which is a free API for making GET and POST 
requests. JSONPlaceholder just gives us a couple  
of API endpoints that we can GET data from and 
POST data to. We can use this to learn about how  
HTTP requests work in React, without needing 
to do anything complex like building an API. 
You'll see I'm using a class-based 
component for this, but this is not required.  
I just want to first show you how to handle HTTP 
requests in class components in case you see  
it in the wild, and then we will quickly 
duplicate the functionality with hooks,  
which as you know are more modern and less 
verbose. This component is pretty simple:  
all it's going to do for us is render some 
posts fetched from the JSONPlaceholder API  
depending on the URL we give it. Each post has 
a unique post ID, a title, an author, and a body.  
In this video, you've learned some high level 
concepts related to HTTP and data fetching in React.
Primarily, you've learned that React 
can happily exist without ever making an  
HTTP request but usually components make these 
requests to send and retrieve data from a server. 
This data is then placed into props our state 
so the React components can render it in the UI.  
We quickly looked at the HTTP request component 
here which uses Axios to make a simple request  
to JSONPlaceholder, and then render some 
generic blog posts that are returned. 
In the next video, you learn how to 
build this component from scratch  
including installing Axios, making a GET request, 
and rendering the returned data in your component.
------ 6rF-WeV0-5M ------
In the previous video, you learned some 
high level concepts related to HTTP and  
working with data in React. We looked at the 
HTTPRequests component and how we can use  
React and Axios to query the JSONPlaceholder 
API to render some data in our component. 
In this video, let’s walk through how to 
write the HTTPRequests component from scratch.
The first thing we need to do is 
install Axios, which is the HTTP  
library we’ll be using to make requests. 
To do it, all you need to do is 
stop your app if it’s running,  
make sure you’re in your main project folder 
and then in the terminal, 'run npm install axios'.
With Axios installed we’ve got everything we need 
to make simple HTTP requests with React. If you  
haven’t done so yet, now is a good time to create 
the new file we’ll be working in, HTTPRequests.js.  
Inside it, I’ll use the rce snippet to 
create a new class component.   
We’ll first build this with a class component, then we’ll 
add some functionality to it in the next video  
to learn about POST requests, and we’ll finish 
up by converting the whole thing to use hooks. 
For now all our component will do is 
return a  tag with the title “Posts:”.
Since this is a class component we’ll also 
need a constructor to make it stateful,  
so I’ll use the snippet rconst just 
inside the first line of the class.  
I’ll give the state a property of posts and 
give it an initial value of an empty array.
This posts property will contain an array of 
posts, each with an id, title, userId and body.  
The posts will be returned 
from the JSONPlaceholder API  
after we use Axios to request 
them. With that much done,  
let’s add the component to App.js and make 
sure we can see it in the preview window. 
Now that the component is up and running, 
it’s time to learn how to use Axios and  
JSONPlaceholder. The first step is to import 
Axios from ‘axios’ at the top of the component.  
This will allow us to use all the 
Axios package’s functionality. 
Next, let’s take a look at JSONPlaceholder’s 
guide and decide what the goal is here.   
As you can see the Axios guide uses the fetch API, but you can still use this guide to  understand how easy it is to use.
To begin, all I want to do is get a list 
of all the posts. If you scroll down a bit  
in the guide you’ll see the section “Listing 
all resources” which shows you how to do it.  
All we need to do is make a GET request to the 
URL,
and then handle the response. In fact, if you open 
this URL in your browser you’ll see the exact data  
we’re going to get back, since requesting 
it in your browser is also a GET request. 
The only difference between what your browser is 
doing and what we’re about to do is that we’re  
going to use Axios to make the request from React, 
and rather than return the data to the browser,  
JSONPlaceholder will return it to our React 
component so we can put it in the state.
The first thing we want to think about is when 
we want to actually make the request to the API.  
As I mentioned in previous videos, immediately 
after the component mounts is usually a good time  
to do this type of work, so the component will 
mount and then immediately and automatically call  
out to the API to get the posts. Can you remember 
the lifecycle method we need to use for this?  
Pause the video for just a minute 
or two here and try to recall it,  
and quickly think about what we 
might want to do in that method. 
If you said componentDidMount, you’re right! The 
process is going to be broken into two steps:  
first making the request to the 
API, and then using the setState  
method to put the data into the state. 
Let’s start with the first step. 
I’ll begin by writing the componentDidMount 
method here above the render() method:
Now, to use Axios to make the request, we can call 
axios.get(), passing it the URL we want to get.  
Remember that we’re using Axios from the 
package we installed at the beginning,  
which is imported at the top.
To handle the response,  
we can use the .then() method which you 
might remember from earlier modules,  
but if not, that’s ok, it’s 
simple to use. I’ll just add  
.then() here, and pass it a function that takes 
the response from the API as its parameter.   
For now, I’ll just log the response to the console.
Let’s run the app and take a look at the console.
You’ll see in here that there’s an object. If you 
open the object up, you’ll find it has a bunch of  
different parts to it, which Axios conveniently 
includes for us to keep everything organized. 
There’s a config property which shows you the 
configuration you sent to JSONPlaceholder,  
some headers, some information about the request, 
a status code of 200 indicating that the request  
completed properly, and most importantly, 
the data, which is an array of post objects,  
each containing an id, title, userId and a body. 
Let’s grab that data and put it into the state.  
Can you think of how we might do this? Pause 
the video and see if you can do it on your own,  
or just think about it for a minute 
or two and then see if you’re right. 
If you picked the setState method, you’re 
absolutely correct! To add this data into the  
state, all we need to do is call this.setState() 
in the .then() function, and set the new state  
to contain posts, equal to response.data.
Then, to render all the data in the component,  
let’s use the JSON.stringify() 
method to stringify this.state.posts.
Now, when you run your component you’ll see 
it automatically calls out to JSONPlaceholder  
and requests a list of posts, which are then 
put into the state and rendered in the UI.  
This is the essence of data fetching in React.
In this video you’ve learned how to build a  
component that automatically fetches data from 
an API using Axios. To quickly review, first we  
installed axios, created a class component 
and imported axios to use in our component.  
Then, we wrote the componentDidMount method which 
uses Axios to reach out to the JSONPlaceholder  
API with a GET request, which requests a 
list of posts. Once the response comes back  
from the API, we take that response and use 
it to put the data from the returned object  
into the state of our component. Finally, 
we render the data from the state in the UI. 
In the next video, we’ll add a little 
more functionality to this component,  
make it look nicer, and learn about error 
handling when working with HTTP requests.
------ -9DiC7EXBm4 ------
In the previous video, you learned how to fetch 
data from an API using Axios in a React component.
We left off with that component successfully 
retrieving the data from the JSONPlaceholder API,  
and rendering it in JSON format in the UI.
In this video, let’s tidy up the 
look of the data we’ve got so far  
and add a little bit more functionality to 
the GET request we wrote in the last video.
You’ll also learn how to handle any 
errors that might occur with your request.
Let’s begin by tidying up the data we 
rendered in JSON format in the last video.
I’ll begin by removing the stringified 
data from the render method  
and to simplify the upcoming code, set a 
const called posts equal to this.state.posts.
This is just so we can shorten our code a bit.
Now, just under the posts heading we’ll 
need to open a set of curly braces  
so we can use JavaScript to iterate 
through the array of posts in the state.
I’m going to start with a 
simple ternary conditional here  
because we really only want to render 
the posts if they exist, and otherwise,  
we should render something like “Loading posts 
...” to indicate the request isn’t complete yet.
So let’s check if posts has a length. 
If so, we will return the list of posts,  
and otherwise, we’ll return a small 
heading reading “Loading posts ...”
The last thing to do then, is to 
actually iterate the array of posts  
and give each one some formatting 
within a simple HTML structure.
I’ll do this using the map method, and for 
each post we’ll return a div which uses the  
post id as a key. Inside each post’s div, 
I’ll render an H2 for the post title and id,  
then an H4 for the userID that posted 
it, and a paragraph for the post body.
I’ll also include a horizontal rule under 
each one to give them some division.
With all that saved, we can run 
our React app in the preview window  
and see the component rendering 
all the posts, nicely formatted. 
Now that the formatting looks quite a lot 
better, let’s add some additional functionality.
The ability to request just a 
single post based on its ID. 
To do this, we can simply attach the id 
of the post desired to the end of the  
existing URL we’re fetching, like this 
one to get the first post from the API,  
which I’ll open in my browser to demonstrate.
If I change the URL in the componentDidMount 
method to try to get this post and save the file,  
you’ll see that the component gets stuck 
on “Loading posts …” when I run the app.
Look at the console and see 
if you can determine why.
Take 5 minutes to pause the video, study 
the object that is returned from the API,  
and see if you can determine what’s wrong.
Welcome back!
What’s wrong is actually quite simple -
the data property in the object returned from 
the API when requesting only a single post  
is just the post itself - an object - rather 
than an array of posts like we saw previously.
In the setState method we’re currently 
setting posts equal to this data property,  
because we’re expecting it 
will be an array already,  
and then trying to check if it 
has a length in the render method.
Since an object has no length property, the 
ternary conditional in the render method  
returns false and the “Loading posts …” message 
is rendered even after the API request completes.  
To fix it, we need to somehow 
check when the response comes back  
whether the data property is an array, 
and then update the state accordingly.
The easiest way to do this is to just use the 
built in isArray() method from JavaScript.
So here let’s adjust our setState call to 
say if response.data is already an array,  
then we will just set posts 
equal to response.data,  
and otherwise, we’ll manually set it equal 
to an array containing response.data,  
because we know that response.data will be an 
object. By doing this, whether you request all  
posts, or a specific post, the state end 
up containing an array of post objects.
With all this done, I can freely update the 
URL in the GET request to get any post ID.
Lastly, I’d like to show you how you can 
use another built in function at the end  
of the get request, called catch(), to catch 
any errors that happen. It’s simple to use,  
all we need to do is add .catch() to the end 
of the .then() code, and pass it a function  
that expects an error object, similar to the 
.then() method expecting a response object:
Inside this error object will be a message 
property containing the error message  
and some information about where it occurred. 
Let’s first add an error property to the state,  
initially set to null, and 
then in the catch method here,  
if we catch an error, we’ll use setState 
to set error in the state to error.message.
Finally, I’ll go to the render method 
and update the code currently rendering  
the loading posts heading to check 
whether this.state.error exists.
If so, we’ll render a paragraph 
with this.state.error in it,  
and otherwise we’ll render 
the loading posts heading.
In this way, I can now request, for example, a 
post that doesn’t exist by changing the URL, and  
see that a 404 error is rendered in the preview 
window. Of course, since you’re now just working  
in HTML and JSX, you could format this however 
you like and create a nice custom error page.
In this video, you’ve learned how to format JSON 
data requested from an API in a react component,  
how to add additional functionality to 
a get request by inspecting and working  
with the type of data that’s returned 
from the API, and how to handle errors. 
In the next video, you’ll learn how 
to POST, or send data to an API.
------ 5lqXeZ8DoNg ------
In the last video you learned how to add some 
additional GET functionality to the HTTPRequest  
component we built, as well as how to handle 
any errors that might occur with your requests. 
In this video, let’s learn how to send data 
to a server or API using a POST request.
To clarify, a GET request is typically used 
to request some data from a server or API  
while a POST request is used to 
send data to a server or API.  
To create interactive web applications, 
you need to know how to do both. 
To understand how to do this, let’s 
create a new component HTTPPost.js.  
Inside it I’ll use the rce snippet to create a new 
class component, and give it the text “it works”:
Now as usual, I’ll just import it into App.js 
and replace the existing component with it.
With that done, we can save the 
component and verify it’s working  
by running the app with npm start.
Inside the component, let’s just create  
a simple button and use that to trigger our 
POST request when it’s clicked. We’ll use the  
JSONPlaceholder API again for this, and will 
simulate adding a post to the list of posts.  
I’m going to give the button an onClick attribute 
and call a function called this.postToApi.  
In the postToApi function I’ll 
just log "it works" for now.
I can now click the button and see 
that it logs “it works” to the console. 
So what do we need to do with this 
little function? If you’re thinking  
we might need Axios, you’re right. Let’s 
import it at the top of the component.
In the postToApi method, let’s replace the 
console log with a call to axios.post().  
This function takes two parameters: a URL we 
would like to POST to, meaning send data to,  
and an object containing the data we want to send.
The URL and the structure of the second parameter 
- the object containing the data you wish to  
send - will differ depending on the API or 
server you’re sending it to. This is because  
every API has different URLs and interacts with 
different types of data and that data will be  
structured in different ways. To figure out 
how to work with the API or server in question,  
most good APIs will have documentation 
telling you exactly what they expect.  
Let’s look at the JSONPlaceholder guide once 
again and learn how to structure our POST request.
Looking at the “creating a resource” section, 
we can see that to create a post we need to make  
a POST request to the /posts endpoint 
and the second parameter, the object,  
looks pretty complex, but luckily 
ours is going to be a lot simpler.  
Let’s go through this code first and 
then we’ll see how to do it ourselves.
The first property specifies the method 
with which we’re going to send the request,  
which in our case is POST. The next one, body, 
specifies the actual data we’re going to send,  
which you can see the API expects to match the 
shape of a post object, containing a title,  
body, and userID that created it. The ID 
field, which we used in the last two videos,  
could also be created here in this object, but 
usually stuff like that will be automatically  
created by the server when it creates the 
new object. The body is “stringified”,  
which means it will be sent as a string 
of text which matches the JSON format.
Lastly, we have to specify 
some HTTP request headers,  
which tell the server or API the type of data 
we’re sending and which character set it uses,  
so it knows how to read it. If none of that 
last bit makes sense, don’t worry, because  
I’m about to show you why Axios is awesome. 
With Axios, we don’t need to do any of that.
Returning to our postToApi function, I’m going to 
replace ‘url’ with the /posts url from the guide.  
Then, with Axios, all we need to do is give 
it the post object itself, so I’ll create a  
new post with a title of ‘Hello world’, a 
body of ‘It works!’, and a userID of 123.
These values can be anything you wish, and in 
fact even the properties can be anything you wish.  
It’s up to the API or server to verify that 
we’re sending it data in the correct format.
So that’s it! With Axios it automatically adds the 
method parameter when we use the .post() function,  
it automatically stringifies the object we send 
as the second parameter, and it automatically adds  
the correct headers, assuming that we’re working 
with JSON data, which almost all APIs accept.
To verify the request was successful, we 
can use the same technique as a GET request.
I’ll add a .then() to the end here,  
which will take in response and 
return a console log of the response.
If you save everything, click the 
button, and check the console,  
you’ll see we get a response from the API with 
an HTTP status of 201, which means “created”.  
In the data property, you can see the 
object we created with our POST request.
As a challenge for the end of this video, I’d 
like you to try and render a simple post component  
based on the response from the 
API. The title can be an h1  
and the rest of the properties can be 
paragraphs. To solidify your understanding  
I recommend adding a state to this component and 
using the techniques you learned in the last video  
to try to get the response into the 
state, and then render it in the UI. 
Pause the video for a few minutes 
and then check out my solution.
Ok welcome back, here’s how I did it.
First, I used the rconst snippet, put 
the API response property in the state  
and initialized it to Null.
Second, I called setState to update the API response property with the API data in the .then method.
Next, in the render method I de-structured 
API response from this.state.
Then, underneath the button I opened curly braces. 
If API response is truthy, I render an h1with the  
API response title and three paragraphs with 
postID, post body, and userID; respectively.
Incase API response is Null, I 
rendered a paragraph that says,  
"Please click the button above".
In this video you’ve learned 
the fundamentals of making an  
HTTP POST request in order to 
send some data to a server or API.
With that knowledge, you’ve got the skills 
you need to be able to work with almost  
any modern API in existence, both getting 
data from it and sending data to it.
In the final video of the React 
Essentials series coming up next,  
you’ll learn to duplicate this functionality 
with hooks and learn where to go from here.
------ DBy0U0oR7-E ------
Before we get into the material in this final
video, I want to first congratulate you on
making it this far!
In this series you have gone from zero to
hero with React, learning everything from
the fundamentals to how to make interactive
components that can call out to an API or
a server all on their own.
With this knowledge you’re on your way to
being able to build complex and powerful web
applications using React.
In this video, we’re going to combine the
last two lessons - the one about hooks, and
this one.
In doing so, we’ll duplicate the functionality
of making GET and POST requests in functional
components that use useState and useEffect.
We’ll continue working with JSONPlaceholder
for this.
For this video we’ll add both GET and POST
functionality to the same component so it
can do multiple things.
First I’ll create a new file called HTTPHooks.js,
and inside it use the snippet rfce to create
a new functional component which returns ‘it
works!’
We will need some imports at the top, so let’s
take care of those now: we need useEffect
and useState from react, and axios from the
Axios package.
Last, I’ll import it into App.js and render
the component to verify it works.
Back in HTTPHooks.js, let’s begin with the
GET functionality.
We can look at HTTPRequests.js to determine
the state properties needed for this portion.
The first one is posts, so I’ll use the
useState hook to create posts and setPosts,
and initialize the posts variable to an empty
array, just like in the stateful class component.
We’ll also need error and setError, which
will be initialized to null,
So far so good.
Since we now have the same state variables,
we can copy the whole structure in the render
method from the other component and render
the same exact output here.
If you save that, you’re going to get an
error.
If you’re not sure what’s wrong, pay close
attention to exactly what’s being rendered
and what type of component you’re working
with here.
Pause the video for 2 minutes right now, and
see if you can fix what’s gone wrong.
Welcome back, as you hopefully realized, the
issue is that we are referencing this.state.error
in the render method, but this is a functional
component so there is no such thing as this.state.
Since we’re using hooks, we need to change
this bit to just “error”.
With that saved, we’ve got the bulk of the
work on the component done and the last thing
to do is actually make the GET request.
For this, we need the useEffect hook.
Again let’s look at HTTPRequests.js to see
what we want to actually do here.
The GET request here is made in the componentDidMount
method, so that’s the functionality we should
be duplicating with the useEffect hook.
Can you remember the key thing we need to
do in order to ensure an effect runs only
when the component mounts?
Pause the video and look back at the useEffect
videos for 3-5 minutes if you need to.
To duplicate the componentDidMount functionality,
we’ll need to pass the useEffect hook the
function we want to execute, as well as an
empty dependency array to prevent it from
running on every render.
Let’s do that now.
So useEffect, and it will take in an arrow
function, and then we’ll pass an empty array
as the second parameter.
Now, luckily we’re back to just copying
and pasting again!
We need to make the same request here in the
useEffect function as we made in HTTPRequests.js
so let’s grab the axios function from there
and put it here in the useEffect hook.
Again, if you save you will get an error message
because we’re still referencing setState,
which only works in class components.
Instead we need to convert these to use our
setter functions defined with the useState
hook.
Let’s clean it up a bit and fix the error.
First I’m going to extract this ternary
conditional out and convert it to a variable
so we can just pass it into the setPosts function.
It’s important not to call this variable
posts, because we don’t want to interfere
with the posts variable created by the useState
hook.
I’m calling it data instead.
Then, I can simply remove the setState call
and replace it with setPosts, passing in data.
Similarly I’m going to remove the setState
call from the error handling block and call
setError instead, passing in error.message.
With that saved, we have the exact same functionality
as HTTPRequests.js, using hooks instead.
If I remove the id at the end of the URL I
get all posts.
If I pass an ID between 1 and 100 I will get
that specific post, and if I pass anything
above 100 I will get a 404 not found error.
By now you can probably guess that it’s
going to be pretty easy to duplicate the HTTPPost.js
component’s functionality here.
Because the POST request is something that
happens on the click of a button, we don’t
need a hook at all!
We can just directly copy and paste the postToApi
function from the original component to this
one, and put const in front of it to define
it as a constant within the HTTPHooks functional
component:
Now we just need to copy the same button from
the previous component and remove “this”
from the onClick attribute.
When I click the button the response from
the API is logged to the console.
Of course I also asked you to render an example
post component at the end of the last video.
For this video, if you want another challenge,
try to convert that component to use hooks.
Otherwise, you can do something simple, just
to demonstrate the concept.
For instance, I could create a state property
using useState called postMessage, give it
a setter of setPostMessage, and then initialize
it to null.
Then I can set it in the .then() portion of
the postToApi function, using setPostMessage.
We’ll set it to a ternary conditional.
If response.status === 201, it will be ‘success’,
and will give us the title of the post created.
Otherwise it will be ‘failed’.
Now, let’s render it just underneath the
button in a paragraph.
When I click the button, the post is created,
giving us a success message in the UI.
In this video you’ve learned how to duplicate
HTTP GET and POST functionality using hooks
in functional components.
Of course, there is so much more you could
do with this knowledge.
Can you imagine a react app with 10,000 components,
all with the ability to update themselves
independently of every other component, all
with the ability to be completely interactive,
and all with the ability to make their own
unique HTTP requests?
This massive potential and flexibility is
the reason companies like Netflix, Twitter
and Facebook opted to use React to build their
hugely successful web applications.
I hope that this small sample of components
helps you understand the implications of React.
As you progress forward in your journey to
master React, I highly recommend looking into
the many extensions and packages available
for it via NPM, as well as continuing your
exploration of what you’ve learned here
- looking at some of the other hooks that
are available such as useContext and useReducer
for example.
React is a huge ecosystem and has tens of
thousands of users and contributors around
the world.
With the essential knowledge you’ve learned
in this module, I hope that you find yourself
among them.
To bring this all together, you’ll work
through building a complete react application
from start to finish, utilizing all the concepts
you’ve learned here.